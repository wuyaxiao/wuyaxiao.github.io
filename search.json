[{"title":"PE文件格式","url":"/2025/04/07/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","content":"PE文件格式\n\nDOS头\n\nMZ文件头：IMAGE_DOS_HEADER 结构体//注释掉的不需要重点分析struct _IMAGE_DOS_HEADER&#123;  0X00 WORD e_magic;      //※Magic DOS signature MZ(4Dh 5Ah):MZ标记:用于标记是否是可执行文件;用于判断PE文件的标识。如果不是MZ即不是十六进制值：0x5A4D。计算机存储顺序是低位在前高位在后，所以存储为：0x4D5A。    //0X02 WORD e_cblp;     //Bytes on last page of file  //0X04 WORD e_cp;       //Pages in file  //0X06 WORD e_crlc;     //Relocations  //0X08 WORD e_cparhdr;  //Size of header in paragraphs  //0X0A WORD e_minalloc; //Minimun extra paragraphs needs  //0X0C WORD e_maxalloc; //Maximun extra paragraphs needs  //0X0E WORD e_ss;       //intial(relative)SS value  //0X10 WORD e_sp;       //intial SP value  //0X12 WORD e_csum;     //Checksum  //0X14 WORD e_ip;       //intial IP value  //0X16 WORD e_cs;       //intial(relative)CS value  //0X18 WORD e_lfarlc;   //File Address of relocation table  //0X1A WORD e_ovno;     //Overlay number  //0x1C WORD e_res[4];   //Reserved words  //0x24 WORD e_oemid;    //OEM identifier(for e_oeminfo)  //0x26 WORD e_oeminfo;  //OEM information;e_oemid specific  //0x28 WORD e_res2[10]; //Reserved words  0x3C DWORD e_lfanew;    //※Offset to start of PE header:定位PE文件，PE头相对于文件的偏移量&#125;;//一个word是对应2个字节，该结构体大小为64个字节，因为里面定义了两个word型数组。  \n\nDos Stub:汇编代码其功能是当该EXE运行在16位环境下，输出一段文字：“This program cannot be run in DOS mode”，然后并退出该进程。  \nPE头:IMAGE_NT_HEADERSPNTHeader = ImageBase + dosHeader-&gt;e_lfanew\ntypedef struct IMAGE_NT_HEADERS&#123;    DWORD Signature;    IMAGE_FILE_HEADER FileHeader;    IMAGE_OPTIONAL_HEADER32 OptionalHeader;  &#125;IMAGE_NT_HEADERS,*PIMAGE_NT_HEADERS;   \n\nSignature将文件标识为 PE 映像的 4 字节签名。字节为“PE\\0\\0”。\nIMAGE_FILE_HEADERIMAGE_FILE_HEADER（映像头文件）结构包含了文件的物理层信息及文件属性。共20字节的数据，其结构如下：\ntypedef struct _IMAGE_FILE_HEADER &#123;  WORD    Machine;                    //运行平台常见【机器：标识】：Intel I386 14ch、MIPS R3000 162h、Alpha AXP 184h、Power PC 1F0h、MIPS R4000 184h  比如这里的014c，就是在Intel I386机器上运行。  WORD    NumberOfSections;           //文件的区块数目  节表中 IMAGE\\_SECTION\\_HEADER结构的总数总是由PE文件头IMAGE\\_NT\\_HEADERS(注：即本资料中的NT头) 结构中的FileHeader.NumberOfSections 字段来指定的。DWORD   TimeDateStamp;              //文件创建日期和时间  DWORD   PointerToSymbolTable;       //指向符号表（用于调试）  DWORD   NumberOfSymbols;            //符号表中符号个数（用于调试）  WORD    SizeOfOptionalHeader;       //IMAGE_OPTIONAL_HEADER32结构大小  紧跟着IMAGE\\_FILE\\_HEADER后面的数据大小，这也是一个数据结构，它叫做IMAGE\\_OPTIONAL\\_HEADER,其大小依赖于是64位还是32位文件。32位文件值通常是00E0h，对于64位值通常为00F0h。  WORD    Characteristics;            //文件属性  Characteristics：文件属性，普通EXE文件这个字段值为010fh，DLL文件这个字段一般是0210h。保存在winnt.h头文件中有个有个表，然后其中有一些二进制及其代表的属性，可以用或的方式去组合这些属性。  &#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;  \n\nIMAGE_OPTIONAL_HEADER32（可选映像头）程序入口点记录在这里，是imagebase+AddressOfEntryPoint\ntypedef struct _IMAGE_OPTIONAL_HEADER &#123;  //  // Standard fields.   //+18h  WORD  Magic;     // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）+1Ah  BYTE   MajorLinkerVersion;   // 链接程序的主版本号+1Bh  BYTE   MinorLinkerVersion;   // 链接程序的次版本号+1Ch  DWORD  SizeOfCode;   // 所有含代码的节的总大小+20h  DWORD  SizeOfInitializedData;  // 所有含已初始化数据的节的总大小+24h  DWORD  SizeOfUninitializedData; // 所有含未初始化数据的节的大小+28h  DWORD  AddressOfEntryPoint;  // 程序执行入口RVA程序入口的RVA，对于exe可以理解为WinMain的RVA。对于DLL可以理解为DllMain的RVA，对于驱动程序，可以理解为DriverEntry的RVA。写壳的时候这个地址相当重要。  +2Ch  DWORD  BaseOfCode;   // 代码的区块的起始RVA+30h  DWORD  BaseOfData;   // 数据的区块的起始RVA  //  // NT additional fields.  以下是属于NT结构增加的领域。  //+34h  DWORD  ImageBase;   // *********程序的首选装载地址+38h  DWORD  SectionAlignment;   // *********内存中的区块的对齐大小节对齐，PE中的节被加载到内存时会按照这个域指定的值来对齐，比如这个值是0x1000，那么每个节的起始地址的低12位都为0。  +3Ch  DWORD  FileAlignment;   // *********文件中的区块的对齐大小节在文件中按此值对齐，SectionAlignment必须大于或等于FileAlignment。  实际上这两个对齐方式很重要，在后续RVA和偏移地址的转化中有用到。  +40h  WORD  MajorOperatingSystemVersion; // 要求操作系统最低版本号的主版本号+42h  WORD  MinorOperatingSystemVersion; // 要求操作系统最低版本号的副版本号+44h  WORD  MajorImageVersion;    // 可运行于操作系统的主版本号+46h  WORD  MinorImageVersion;    // 可运行于操作系统的次版本号+48h  WORD  MajorSubsystemVersion; // 要求最低子系统版本的主版本号+4Ah  WORD  MinorSubsystemVersion; // 要求最低子系统版本的次版本号+4Ch  DWORD  Win32VersionValue;    // 莫须有字段，不被病毒利用的话一般为0+50h  DWORD  SizeOfImage;    // 映像装入内存后的总尺寸+54h  DWORD  SizeOfHeaders;    // 文件头的长度之和+58h  DWORD  CheckSum;    // 映像的校检和+5Ch  WORD  Subsystem;    // 可执行文件期望的GUI或CUI图形用户界面，字符用户界面+5Eh  WORD  DllCharacteristics;    // DllMain()函数何时被调用，默认为 0+60h  DWORD  SizeOfStackReserve;    // 初始化时的栈大小+64h  DWORD  SizeOfStackCommit;    // 初始化时实际提交的栈大小+68h  DWORD  SizeOfHeapReserve;    // 初始化时保留的堆大小+6Ch  DWORD  SizeOfHeapCommit;    // 初始化时实际提交的堆大小+70h  DWORD  LoaderFlags;    // 与调试有关，默认为 0 +74h  DWORD  NumberOfRvaAndSizes; // 下边数据目录的项数，这个字段自Windows NT 发布以来    // 一直是16+78h  DWORD  DataDirctory[16];     // ********* 数据目录表&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n\nDataDirectory构建原因：数据目录表-每个结构给出一个重要数据结构的起始RVA和大小信息。节表可以看作是PE文件各节的根目录的话，也可以认为 data directory 是存储在这些节里的逻辑元素的根目录。\n\n\n数据目录，这是一个数组，数组的项定义如下：\ntypedefstruct _IMAGE_DATA_DIRECTORY &#123;DWORD   VirtualAddress;DWORD   Size;&#125; IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;VirtualAddress\n\n有16个这样的元素\n#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   //0 导出表#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   //1 导入表   #define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   //2 资源目录#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   //3 异常目录#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   //4 安全目录#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   /5 重定位基本表#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory     // IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)  #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data  #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP  #define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory  #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory  #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers  #define IMAGE_DIRECTORY_ENTRY_IAT            12   // 导入地址表#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors  #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor  \n\n动态链接\nDataDirectory在动态链接过程中起着重要作用\n\n\n 动态链接后IAT的内容会被替换为地址\n\n\n该过程主要涉及以下三个表：\n\n导入表：一个引入函数是被某模块调用但又不在调用模块中的函数，位于一个或者更多的DLL里，因而要保留一些函数信息，包括函数名及其驻留的DLL名。（给出函数定义）\n装载器首先读入IMAGE_IMPORT_DESCRIPTOR，获得需要加载的动态库User32.DLL。\n然后如上图所示会创建两个并列的指向IMAGE_IMPORT_BY_NAME结构的指针数组。第一个数组（由Characteristics域指向的那一个）总是保留原样，系统并不修改。第二个数组（由FirstThunk域指向的那一个）要被PE加载器修改。改成引入函数真实地址 \ntypedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;    union &#123;        DWORD Characteristics; // 0 for terminating null import descriptor  别名        DWORD OriginalFirstThunk; // RVA to original unbound IAT，指向导入函数的定义         (指向IMAGE_THUNK_DATA结构数组的RVA)    &#125;;    DWORD TimeDateStamp; // 0 if not bound,    // -1 if bound, and real date\\time stamp    // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)    // O.W. date/time stamp of DLL bound to (Old BIND)    DWORD ForwarderChain; // -1 if no forwarders    DWORD Name;  // RVA，指向字符串，是这个可执行文件的名字。指向名字的指针                                      例如“kernel32.dll&quot;    DWORD FirstThunk; // RVA to IAT (if bound this IAT has actual addresses)，在加载前给出导入函数的定义（对齐：前面函数对齐，后面就可以与其地址进行一一对应），在加载后指向导入函数的地址    (指向IMAGE_THUNK_DATA结构数组的RVA)&#125; IMAGE_IMPORT_DESCRIPTOR;typedef struct _IMAGE_THUNK_DATA32 &#123;    union &#123;        DWORD ForwarderString; // 一个RVA地址，指向forwarder string         DWORD Function; // PDWORD，被导入的函数的入口地址        DWORD Ordinal; // 该函数的序数        DWORD AddressOfData; // 一个RVA地址，指向IMAGE_IMPORT_BY_NAME    &#125; u1;&#125; IMAGE_THUNK_DATA32; typedef struct _IMAGE_IMPORT_BY_NAME&#123;     WORD Hint;// 函数输出序号     BYTE Name1[i];//输出函数名称&#125; IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME\n\n导出表：存储导入函数地址\n根据IMAGE_IMPORT_BY_NAME的序号或名称到导入的DLL(user32.dll)函数导出表中获取导入函数的地址。然后把这个地址替换掉FirstThunk所指向的函数输入地址表中的数据。\n可以按照序号导出也可以按照名称导出 \n\n\ntypedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD  Characteristics;       // 一般为0 DWORD  TimeDateStamp;         // 文件生成时间 WORD   MajorVersion;          // 主版本号 WORD   MinorVersion;          // 次版本号 DWORD  Name;                  // 指向DLL的名字 DWORD  Base;                  // 基数，加上序数就是函数地址数组的索引值 DWORD  NumberOfFunctions;     // AddressOfFunctions数组的项数 DWORD  NumberOfNames;         // AddressOfNames数组的项数 DWORD  AddressOfFunctions;    // RVA from base of image（每个函数具体导出的地址值） DWORD  AddressOfNames;        // RVA from base of image（按名称导出） DWORD  AddressOfNameOrdinals; // RVA from base of image（把序号和名称做了一个对，使其能按序号导出）&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;\n\n导入地址表：IAT\n而JMP DWORD PTR [XXXXXXXX]这条指令中的[XXXXXXXX]部分就是这个FirstThunk数组中的某个元素的值。由于被加载器覆盖的这个指针数组最终保存的是导入函数的地址，因此它被称为导入地址表（Import Address Table，IAT）。\n对应输入表位置和大小\n\n\n采用PEinfo所查到输入表位置与大小  \n\n\n节表&#x2F;区块表:_IMAGE_SECTION_HEADER*一定数量typedef struct _IMAGE_SECTION_HEADER &#123;  Name                        //8个字节的块名  区块名。这是一个由8个ASCII码组成，用来定义区块的名称的数组。多数区块名都习惯性以一个“.”作为开头（例如：.text），这个“.”实际上是不是必须的。union//2选1                         &#123;      DWORD PhysicalAddress;      DWORD VirtualSize;  //本节的实际字节数，默认就是这个值&#125; Misc;                     //区块尺寸DWORD VirtualAddress;       //本节的相对虚拟地址该块时装载到内存中的RVA，注意这个地址是按内存页对齐的，她总是SectionAlignment的整数倍，在工具中第一个块默认RVA为1000，在OBJ中为0。DWORD SizeOfRawData;        //在文件中对齐后的尺寸  该块在磁盘中所占的大小,在可执行文件中，该字段包括经过FileAlignment调整后块的长度。例如FileAlignment的大小为200h，如果VirtualSize中的块长度为19Ah个字节，这一块保存的长度为200h个字节。  DWORD PointerToRawData;     //在文件中偏移  该块在磁盘文件中的偏移，程序编译或汇编后生成原始数据，这个字段用于给出原始数据块在文件的偏移，如果程序自装载PE或COFF文件（而不是由OS装载），这种情况，必须完全使用线性映像方法装入文件，需要在该块处找到块的数据。  DWORD PointerToRelocations; //在OBJ文件中使用，重定位的偏移  DWORD PointerToLinenumbers; //行号表的偏移（供调试使用地）  WORD NumberOfRelocations;   //在OBJ文件中使用，重定位项数目  WORD NumberOfLinenumbers;   //行号表中行号的数目  DWORD Characteristics;      //区块属性如可读，可写，可执行等  &#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;  \n\n\n\nPE文件加载过程Windows 装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系。当且仅当真正执行到某个内存页中的指令或者访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存\n  \n\n当一个PE文件被加载到内存中以后，我们称之为“映象”（image），一般来说，PE文件在硬盘上和在内存里是不完全一样的，被加载到内存以后其占用的虚拟地址空间要比在硬盘上占用的空间大一些，这是因为各个节在硬盘上是连续的，而在内存中是按页对齐的，所以加载到内存以后节之间会出现一些“空洞”【补的0】。 \n\n","categories":["软件安全"],"tags":["PE文件","笔记"]},{"title":"hexo的使用方法(在Next主题下)","url":"/2025/04/06/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-%E5%9C%A8Next%E4%B8%BB%E9%A2%98%E4%B8%8B/","content":"根据我对博客的要求作出的一些配置。\n\n站点配置文件: /your-hexo-blog/config.yml\nNext 主题配置文件: /your-hexo-blog/themes/next/_config.yml\n\n设置分类和标签主题配置在 Next 主题下找到hex-theme-next_config.yml 这个路径的配置文件,然后打开这个文件并修改代码。\nmenu:  home: / || fa fa-home  # about: /about/ || fa fa-user  tags: /tags/ || fa fa-tags # 取消注释，开启标签  categories: /categories/ || fa fa-th # 取消注释，开启分类  archives: /archives/ || fa fa-archive  # schedule: /schedule/ || fa fa-calendar  # sitemap: /sitemap.xml || fa fa-sitemap  # commonweal: /404/ || fa fa-heartbeat\n\n创建文件创建标签文件在博客项目所在文件夹下执行以下命令：\nhexo new page tags\n\n成功后会提示：\nINFO  Created: ~/blog/source/tags/index.md\n\n根据成功后到提示路径打开index.md这个页面文件并增加一行type: &quot;tags&quot;。\ntitle: tagsdate: 2025-04-06 08:16:29type: &quot;tags&quot;\n\n创建分类文件在博客项目所在文件夹下执行以下命令：\nhexo new page categories\n\n成功后会提示：\nINFO  Created: ~/blog/source/categories/index.md\n\n根据成功后到提示路径打开index.md这个页面文件并增加一行type: &quot;categories&quot;。\ntitle: categoriesdate: 2025-04-06 08:10:09type: &quot;categories&quot;\n\nHexo基本操作创建博客：\nhexo n\n\n\n\n打包上传文件：\nhexo cleanhexo generatehexo deploy\n\n\n\n在本地运行代码：\n$ hexo s -gINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.\n\n添加动态背景\n由于NexT 8.0.0-rc.2移除了canvas-nest集成，所以我们要自行创建文件，根据官网的操作来就可以了。\n在your-hexo-blog/source/_data目录下新建文件footer.swig：\n&lt;script color=&quot;0,0,255&quot; opacity=&quot;0.5&quot; zIndex=&quot;-1&quot; count=&quot;99&quot; src=&quot;https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js&quot;&gt;&lt;/script&gt;\n\n修改站点配置文件，配置footer路径：\n解释# Define custom file paths.# Create your custom files in site directory `source/_data` and uncomment needed files below.custom_file_path:  #head: source/_data/head.swig  #header: source/_data/header.swig  #sidebar: source/_data/sidebar.swig  #postMeta: source/_data/post-meta.swig  #postBodyEnd: source/_data/post-body-end.swig  footer: source/_data/footer.swig  #bodyEnd: source/_data/body-end.swig  #variable: source/_data/variables.styl  #mixin: source/_data/mixins.styl  #style: source/_data/styles.styl\n\n上传图片站点配置将站点配置中的post_asset_folder设为true\npost_asset_folder: true\n\ntypora中的图像保存位置设置点开文件——&gt;偏好设置，设置如下：\n\n安装插件在根目录下打开git bash，然后运行以下命令中的一个（我在网上查资料的时候发现这两个命令其中有一个可能实现不了，具体是哪个要看环境）\nnpm install https://github.com/xcodebuild/hexo-asset-image.gitnpm install hexo-asset-image -- save\n\nNote：由于本身Hexo带有缓存会导致插件第一次使用可能会出现无效果，请使用hexo clean清除缓存后即可正常使用；\n设置博文目录Hexo 的 Next 主题是可以自动展开文章目录的，其在默认情况下并未开启，需要手动开启。\n1.修改主题配置文件 _config.yml打开 next 主题的 _config.yml 文件，搜索 custom_file_path，可以看到如下内容：\ncustom_file_path:  #head: source/_data/head.swig  #header: source/_data/header.swig  #sidebar: source/_data/sidebar.swig  #postMeta: source/_data/post-meta.swig  #postBodyEnd: source/_data/post-body-end.swig  #footer: source/_data/footer.swig  #bodyEnd: source/_data/body-end.swig  #variable: source/_data/variables.styl  #mixin: source/_data/mixins.styl  #style: source/_data/styles.styl\n\n修改 style 属性，即取消相应注释\n2.创建 _data 文件夹并添加 styles.styl 文件找到博客所在的根目录下的 source 文件夹，也之后，创建 _data/styles.styl 文件\n3.修改 styles.styl 文件在文件中添加如下代码\n//文章目录默认展开.post-toc .nav .nav-child &#123;     display: block; &#125;//文章目录字体大小调整.post-toc ol &#123;      font-size : 13px;     &#125;\n\n4.修改主题配置文件\n最后，修改主题配置文件 \n搜索 toc 配置项，进行以下更改：\n# 文章目录toc:  # 开启文章目录  enable: true  # 自动将列表编号添加到 toc  number: true  # 当设为 true 时，如果标题宽度大于侧边栏宽度，则将文字放在下一行  wrap: true\n\n开启搜索功能安装相关插件在博客根目录下执行以下命令：\n$ npm install hexo-generator-searchdb --save\n\n配置博客编写站点配置文件\nsearch:  path: search.xml  field: post  format: html  limit: 10000\n\n配置主题编写主题配置文件\n找到文件中 Local search 的相关配置，设为 true\n# Local searchlocal_search:  enable: true\n\n","categories":["使用指南"],"tags":["hexo","Next主题"]},{"title":"http/https交互过程","url":"/2025/04/06/http-https%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B/","content":"http交互过程\n\n用wireshark抓包后利用百度ip地址过滤数据包ipv6.src &#x3D;&#x3D; 240e:ff:e020:966:0:ff:b042:f296 || ipv6.dst &#x3D;&#x3D; 240e:ff:e020:966:0:ff:b042:f296\n\n“三次握手”建立TCP连接\n客户端发送HTTP请求\n客户端向服务器发送HTTP请求消息。请求消息通常包括以下部分：\n\n请求行：包含请求方法（如GET、POST）、请求的资源路径、HTTP版本。\nRequest Method：请求方法，这里的请求方法是GET；\nRequest URI：请求的URI，没指定默认是&#x2F;，因为我们只请求了域名www.baidu.com，并没指定要获取的资源，所以是默认的/；\nRequest Version：请求的版本，因为用的是HTTP协议，所以这里显示HTTP协议的版本。\n\n\n请求头：包含客户端信息、请求参数等，例如User-Agent、Accept、Cookie等。\nHost：目标主机；\n\nUser-Agent：用户代理，也就是浏览器的类型。由于我们没用浏览器，所以这里显示的是命令curl，版本为8.4.0；\n\nAccept：浏览器可接受的MIME（Multipurpose Internet Mail Extensions）类型。\n\n\n\n请求体：对于某些请求方法（如POST），可能包含额外的数据，用于向服务器发送信息。\n\n服务器发送HTTP响应\n服务器接收到请求后，会检查请求头和请求体，然后根据请求方法（如GET、POST）和资源路径来决定如何响应。服务器生成的响应消息，包括状态行、响应体。\n当打开响应体会发现它的内容是明文的，对于机密通信来说HTTP通信很容易产生信息泄露。另外，以上介绍的整个交互过程中并不验证通信方的身份，第三方可以冒充他人身份参与通信。\n\nHTTP 响应结构这个内容是一个标准的HTTP响应示例，使用的是HTTP&#x2F;1.1协议。响应的结构主要分为几个部分：\n\n状态行： \nHTTP/1.1 200 OK\n\n\nResponse Version: 表示使用的HTTP协议版本（HTTP&#x2F;1.1）。\nStatus Code: 200，表示请求成功。\nStatus Code Description: “OK”是对状态代码的描述，表示没有错误。\n\n\n响应头部：接下来是一系列以字段名: 字段值方式排列的响应头部信息，其中包括：\n\nConnection: keep-alive指示连接是否保持活动状态，允许在一个TCP连接上处理多个请求。\nContent-Length: 413830表示响应主体的长度（字节数）。\nContent-Type: text/html; charset=utf-8表明返回内容的类型为HTML，并使用UTF-8字符集编码。\nDate: 指示服务器发送响应的日期和时间（GMT）。\nServer: BWS/1.1表示服务器使用的Web服务器软件名称和版本。\nSet-Cookie: 多个Set-Cookie字段设置会话 cookie，以便客户端可以在后续请求中识别用户。这些设置包括：\nBIDUPSID: 用于标识用户的会话 ID。\nPSTM: 时间戳。\nH_PS_PSSID: 字段用于会话跟踪。\nBAIDUID: 用户ID，通常用于个性化和跟踪。\n\n\nTraceid: 1727528586052408013810636502756405498072是用于跟踪请求的唯一标识符。\nVary: Accept-Encoding表示响应可能会根据请求头中的Accept-Encoding进行变化。\nX-Ua-Compatible: 浏览器兼容性设置，指定最优渲染引擎。\nX-Xss-Protection: 1;mode=block用于防止跨站脚本攻击（XSS）。\n\n\n响应主体：\n&lt;Response: True&gt;\n\n“四次挥手”断开TCP连接\n请求完成后，客户端和服务器可以关闭连接。通常情况下，HTTP 1.0使用的是短连接，请求完成后关闭连接。HTTP 1.1默认使用长连接，多个请求可以复用同一个连接，直到连接超时或被关闭。\nhttps交互过程HTTP协议有三大缺点：\n\n机密性问题：通信使用了明文，第三方可以拦截并获悉通信内容；\n完整性问题：未验证报文的完整性，第三方可以篡改通信内容；\n认证问题：未验证对方的身份，第三方可以冒充他人身份参与通信。\n\n为了解决以上三个问题，便诞生了HTTPS。\nHTTPS 被称为 HTTP Over SSL (基于SSL加密的HTTP)，这里的SSL (Secure Socket Layer) 被称为安全套接层，它是一种加密协议，不仅可应用于HTTP协议、还可应用于POP3协议、SMTP协议、VPN等。\nTLS (Transport Layer Security) 被称为传输层安全，TLS相对于SSL 3.0版本做了些修改和功能增强，相当于SSL的升级版本，所以有时也一起统称为 SSL，接入来本文若不明显强调，SSL就默认表示SSL&#x2F;TLS。\n我们可以用公式HTTPS &#x3D; HTTP + SSL &#x2F; TLS来表示HTTPS。\n\n阶段一：TCP三次握手建立连接\n阶段二：TLS握手建立安全通道\n第一次握手报文（72）：我-&gt;百度 发送TLS消息「Client Hello」；第二次握手报文（74、79）：\n百度-&gt;我 发送TLS消息「Server Hello」；百度-&gt;我 发送TLS消息「Certificate」，「Server Key Exchange」，「Server Hello Done」\n第三次握手报文（83）：我-&gt;百度 发送TLS消息「Client Key Exchange」，「Change Cipher Spec」，「Encrypted Handshake Message」第四次握手报文（85）：百度-&gt;我 发送TLS消息「Change Cipher Spec」，「Encrypted Handshake Message」为了直观展示TLS报文交互，基于抓包分析的数据包可以绘制得到下图。\n\nTLS第一次握手：client -&gt; server (Client Hello)客户端向服务端发送：\n\n客户端支持的协议；\n已经使用的TLS版本；\n随机数Random；\n支持的密码套件。\n\n从下图中，我们也可以看出SSL层是基于TCP层又进行封装的一层协议。\n\n接下来我们看几个TLS协议中的重要字段（Version、Random、SessionID和Cipher Suites）。\n\nversion\n\n从上图中可以看到当前通信安全层协议版本（Version）为TLS 1.2。其实TLS共总有4个版本，最新为TLS 1.3，具体如下：\nTLS 1.3：发布于2018年，TLS 1.3是TLS协议的最新版本，大幅简化了握手过程，提高了性能和安全性。它删除了一些不安全的加密算法，并引入了0-RTT（零往返时间）握手，以减少延迟。TLS 1.2：TLS 1.2发布于2008年，它引入了更强的加密算法和更灵活的密码套件选择，修复了许多安全漏洞，是目前广泛使用的版本。（当前样例中百度网站使用的就是TLS 1.2协议）TLS 1.1：TLS 1.1发布于2006年，引入了一些改进，包括对CBC（Cipher Block Chaining）模式的安全性改进，但仍然存在一些已知的安全问题。TLS 1.0：TLS 1.0于1999年发布，是SSL 3.0的升级版本，修复了一些安全漏洞，但仍然存在一些安全问题。\n\nRandom\n\nRandom用于密钥的制作。这里我们将第一次握手中客户端发送给服务端的随机数记为Client Random，记住这个随机数，后面还会用到。\n\nSessionID\n\nSessionID用来表示客户端是否想复用先前存在的session。如果不复用，则此字段为0；如果想要复用，则此字段为想要复用的sessionID。是否复用由服务端确定。\n\nCipher Suites\n\n密码套件列表会全部发给服务端，服务端从中挑选一个最安全的密码套件返回客户端。\n将Cipher Suites字段展开，如下图。代表客户端支持的密码套件列表。\n\n密码套件的格式通常由一系列的加密算法和相关参数组成。一般来说，它的格式包含以下几个部分：\n密钥交换算法：用于协商会话密钥，例如 Diffie-Hellman（DHE）、ECDHE等。身份验证算法：也称签名算法用于验证对端身份，例如RSA。加密算法：用于实际数据传输的加解密，例如 AES（Advanced Encryption Standard）、RC4 等。数据摘要算法：用于计算哈希，主要是用于验证数据的完整性，防止信息被篡改。\n格式：「密钥交换算法 + 签名算法（认证算法） + 对称加密算法 + 摘要算法」。其中密钥交换算法和签名算法可以相同，此时就会合二为一。\n比如上面密码套件列表中的第9个TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384。\n在这个例子中：\nECDHE表示密钥交换算法是基于椭圆曲线的 Diffie-Hellman（ECDHE）。RSA表示使用RSA算法（私钥加密、公钥解密）验证对方身份。AES_256_GCM表示使用 256 位的 AES 加密算法和 GCM 模式。SHA384表示使用 SHA-384 作为消息摘要算法。\n不同的密码套件组合提供了不同的安全性和性能特点，服务器和客户端在进行 TLS 握手时会协商选择双方都支持的 Cipher Suite 来建立安全连接。\n客户端发送完「Client Hello」（第72个报文），第73个报文则是服务端向客户端发送的ACK确认消息，代表上面的「Client Hello」已经收到。这里也可以看出服务端是通过普通的TCP 的ACK消息去应答「Client Hello」。\nTLS第二次握手：server -&gt; client (1.Server Hello; 2.Certificate,Server key Exchange,Server Hello Done)这一次握手时，server向client连续发送了两个报文：\nServer Hello：服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书；Certificate,Server key Exchange,Server Hello Done：目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。\n服务端发送报文：Server Hello服务端向客户端发送：\n\n服务端支持的协议；\n使用的TLS版本；\n随机数Random；\n服务端选用的密码套件。\n\n\n上图中可以看到，服务端也生成了一个随机数，并发送给了客户端，服务端生成的随机数记为Server Random。\n客户端和服务端就已确认了 TLS 版本和使用的密码套件TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 。\n服务端发送报文：Certificate,Server key Exchange,Server Hello Done这里服务端在一个数据包中发送了三个TLS消息：\n\nCertificate\nServer key Exchange\nServer Hello Done\n\n\ncertificate可以看到当前数据包中包含了三个数字证书，三个证书实际构成了一个完整的证书链。\n最下面的为根证书，最上面的为网站证书。\n\nServer Key Exchange之前由于服务端选用ECDHE进行密钥协商，所以可以看到「Sever Key Exchange」消息中主要包括密钥交换算法EC Diffie-Hellman（简称ECDHE）以及携带的额外数据（Server Params）。Server Params参数包含：Curve Type、Named Curve以及Pubkey，分别代表曲线类型、曲线名称以及椭圆曲线公钥（用于实现密钥交换算法）。为了防止公钥被篡改，这里服务端使用RSA私钥对椭圆曲线公钥进行签名并发送给客户端。\n实质上这个过程服务器做了三件事情：\n\n选择了名为 named_curve 的椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；\n生成随机数会作为服务端椭圆曲线的私钥，保留到本地；\n根据基点 G 和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端。\n\nServer Hello Done表明Server Hello消息结束，这个消息中没有额外的其他字段。\n\nTLS第三次握手client -&gt; server (Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message)该报文中，也是将TLS的三个消息合并到一个中发送。\n\nClient Key Exchange客户端收到了服务端的证书及「Server Hello Done」消息后，会先校验证书，校验通过后会将Client Params数据传递给服务端，其中包含自身生成的椭圆曲线公钥（Pubkey），数据内容如图所示：\n\n客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥，然后用「Client Key Exchange」消息发给服务端。\n至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都可计算椭圆曲线的交点（x，y）。\n最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三者结合生成的。\nChange Cipher Spec「Change Cipher Spec」消息表示客户端已经生成密钥，并切换到对称加密模式。\n\nEncrypted Handshake Message发送这个消息有两个目的：\n告诉服务端，客户端在握手的过程中收到和发送的数据做一个摘要并用会话密钥加密发送给服务端做校验，保证TSL握手过程中报文没有被修改过；\n如果服务端收到这个消息并能解密成功，就能说明对称密钥是正确的。\n「Encrypted Handshake Message」消息其实不只是客户端会发送，之后服务端也会发送一个。\nTLS 第四次握手server -&gt; client (Change Cipher Spec,Encrypted Handshake Message)服务器也是同样的操作，发送「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么TLS握手正式完成。\n最后，就用会话密钥加解密 HTTPS 请求和响应了，即开启了阶段三的加密通信。\n阶段三：加密通信TLS握手完成后，客户端与服务端的所有通信内容均被加密，如果没有会话密钥则无法解密通信内容。\n\n阶段四：TCP四次挥手断开连接\n","categories":["web技术"],"tags":["HTTP协议","HTTPS协议","作业"]},{"title":"操作系统实验","url":"/2025/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/","content":"rCore-Tutorial-v3实验\nlab1编程作业总结编程内容Log Info\n实现自定义日志记录器结构体 SimpleLogger：\n\n创建一个名为 SimpleLogger 的结构体，实现 Log trait 中的方法： enabled、 log 和 flush。这些方法用于判断日志记录是否启用、记录日志消息以及刷新日志。\n在 enabled 方法中，始终返回 true，表示日志记录一直是启用状态。\n在 log 方法中，根据日志级别设置不同的终端文字颜色，然后使用 println! 打印彩色日志消息。\nflush 方法在这里留空。\n\nimpl Log for SimpleLogger &#123;    fn enabled(&amp;self, _metadata: &amp;Metadata) -&gt; bool &#123;        true    &#125;    fn log(&amp;self, record: &amp;Record) &#123;        if !self.enabled(record.metadata()) &#123;            return;        &#125;        let color = match record.level() &#123;            Level::Error =&gt; 31, // Red            Level::Warn =&gt; 93,  // BrightYellow            Level::Info =&gt; 34,  // Blue            Level::Debug =&gt; 32, // Green            Level::Trace =&gt; 90, // BrightBlack        &#125;;        //&quot;\\x1b[31mhello world\\x1b[0m&quot;        println!(            &quot;\\u&#123;1B&#125;[&#123;&#125;m[&#123;:&gt;5&#125;] &#123;&#125;\\u&#123;1B&#125;[0m&quot;,            color,            record.level(),            record.args(),        );    &#125;    fn flush(&amp;self) &#123;&#125;&#125;\n\n初始化日志记录器：\n\n\n\n创建一个 init 函数，在函数内部进行日志记录器的初始化工作。\n定义一个静态变量 LOGGER，其类型为生成的 SimpleLogger 实例。\n将 LOGGER 设置为全局默认的日志记录器，确保它在整个程序生命周期中使用相同的日志实例。\n使用 log crate 中的 set_max_level 方法，根据环境变量 “LOG” 的值，选择相应的日志级别。通过 match 匹配语句将环境变量的值转换为对应的 log crate 中的 LevelFilter 类型的日志级别。\n\npub fn init() &#123;    static LOGGER: SimpleLogger = SimpleLogger;    log::set_logger(&amp;LOGGER).unwrap();    log::set_max_level(match option_env!(&quot;LOG&quot;) &#123;        Some(&quot;ERROR&quot;) =&gt; LevelFilter::Error,        Some(&quot;WARN&quot;) =&gt; LevelFilter::Warn,        Some(&quot;INFO&quot;) =&gt; LevelFilter::Info,        Some(&quot;DEBUG&quot;) =&gt; LevelFilter::Debug,        Some(&quot;TRACE&quot;) =&gt; LevelFilter::Trace,        _ =&gt; LevelFilter::Off,    &#125;);&#125;\n\nKernel Info\n实验思路总结：\n\n\n在 rust_main 函数中，首先通过 extern &quot;C&quot; 声明了一系列外部函数，这些函数用于获取内核各个段（text、rodata、data、bss）的起止地址，以及栈的上下界。\n调用 logging::init() 函数，初始化日志记录器。\n使用 info!、 error!、 warn!、 debug! 宏输出不同级别的日志信息，包括各个段的起止地址等内核信息。使用println输出”hello world”。\n\npub fn rust_main() -&gt; ! &#123;    extern &quot;C&quot; &#123;        fn stext(); // begin addr of text segment        fn etext(); // end addr of text segment        fn srodata(); // start addr of Read-Only data segment        fn erodata(); // end addr of Read-Only data ssegment        fn sdata(); // start addr of data segment        fn edata(); // end addr of data segment        fn sbss(); // start addr of BSS segment        fn ebss(); // end addr of BSS segment        fn boot_stack_lower_bound(); // stack lower bound        fn boot_stack_top(); // stack top    &#125;    clear_bss();    logging::init();    println!(&quot;[kernel] Hello, world!&quot;);    info!(        &quot;[kernel] .text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;,        stext as usize,        etext as usize    );    error!(        &quot;[kernel] .rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;,        srodata as usize, erodata as usize    );    warn!(        &quot;[kernel] .data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;,        sdata as usize, edata as usize    );    debug!(        &quot;[kernel] boot_stack top=bottom=&#123;:#x&#125;, lower_bound=&#123;:#x&#125;&quot;,        boot_stack_top as usize, boot_stack_lower_bound as usize    );    info!(&quot;[kernel] .bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;, sbss as usize, ebss as usize);    ……&#125;\n\n\n\n运行截图\n问答作业请学习 gdb 调试工具的使用(这对后续调试很重要)，并通过 gdb 简单跟踪从机器加电到跳转到 0x80200000 的简单过程。只需要描述重要的跳转即可，只需要描述在 qemu 上的情况。Qemu 启动后 PC 被初始化为 0x1000 。我们可以检查一下 Qemu 的启动固件的内容：\n(gdb) x/10i $pc=&gt; 0x1000:  auipc   t0,0x00x1004:     addi    a1,t0,320x1008:     csrr    a0,mhartid0x100c:     ld      t0,24(t0)0x1010:     jr      t00x1014:     unimp0x1016:     unimp0x1018:     unimp0x101a:     0x80000x101c:     unimp\n\n Qemu 的固件仅包含 5 条指令，从 0x1014 开始都是数据，当数据为 0 的时候则会被反汇编为 unimp 指令。 0x101a 处的数据 0x8000 是能够跳转到 0x80000000 进入启动下一阶段的关键。在执行位于 0x1010 的指令之前，寄存器 t0 的值恰好为 0x80000000 ，随后通过 jr t0 便可以跳转到该地址。\n(gdb) si0x0000000000001004 in ?? ()(gdb) si0x0000000000001008 in ?? ()(gdb) si0x000000000000100c in ?? ()(gdb) si0x0000000000001010 in ?? ()(gdb) p/x $t01 = 0x80000000(gdb) si0x0000000080000000 in ?? ()\n\n可以看到，当位于 0x1010 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 0x80000000 ，这意味着我们即将把控制权转交给 RustSBI 。\n(gdb) x/10i $pc=&gt; 0x80000000:      auipc   sp,0x280x80000004: mv      sp,sp0x80000008: lui     t0,0x40x8000000a: addi    t1,a0,10x8000000e: add     sp,sp,t00x80000010: addi    t1,t1,-10x80000012: bnez    t1,0x8000000e0x80000016: j       0x8001125a0x8000001a: unimp0x8000001c: addi    sp,sp,-48(gdb) si0x0000000080000004 in ?? ()(gdb) si0x0000000080000008 in ?? ()(gdb) si0x000000008000000a in ?? ()(gdb) si0x000000008000000e in ?? ()\n\n接下来我们检查控制权能否被移交给我们的内核：\n(gdb) b *0x80200000Breakpoint 1 at 0x80200000(gdb) cContinuing.Breakpoint 1, 0x0000000080200000 in ?? ()\n\nlab2编程作业总结编程内容\n这里对于每次的输出都检查str地址是否在加载运行程序的地址范围内。\n\npub fn sys_write(fd: usize, buf: *const u8, len: usize) -&gt; isize &#123;    match fd &#123;        FD_STDOUT =&gt; &#123;            if (((buf as usize)  &gt;= USER_STACK.get_sp() - USER_STACK_SIZE) &amp;&amp; ((buf as usize) + len &lt;= USER_STACK.get_sp()))             || (((buf as usize) + len &lt;= APP_SIZE_LIMIT + APP_BASE_ADDRESS) &amp;&amp; ((buf as usize) &gt;= APP_BASE_ADDRESS))&#123;                ……            &#125;else&#123;                ……            &#125;        &#125;,        ……    &#125;&#125;\n\n\n\n运行结果\n问答作业正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容 (运行 Rust 三个 bad  测例 (ch2b_bad_*.rs) ， 注意在编译时至少需要指定 LOG&#x3D;ERROR 才能观察到内核的报错信息) ，  描述程序出错行为，同时注意注明你使用的 sbi 及其版本。Rustsbi 版本为: 0.2.0-alpha.2\n出现报错:\n[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003c4, kernel killed it.[kernel] IllegalInstruction in application, kernel killed it.[kernel] IllegalInstruction in application, kernel killed it.\n\nch2b_bad_address.rs 由于除0错误触发异常退出 \nch2b_bad_instructions.rs 在用户态非法使用指令sret\nch2b_bad_register.rs 在用户态非法使用指令csrr\n深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。\n\n刚进入 __restore 时，a0 代表了系统调用的第一个参数\n__restore 的作用包括:\n\n\n从系统调用和异常返回时, 恢复要返回的用户态的上下文信息\n任务切换时, 恢复要切换的任务的上下文信息\n\n\nL43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。ld t0, 32*8(sp) # 内核栈 32*8(sp) 处存储了原 sstatus 寄存器的值, 将其读取到 t0ld t1, 33*8(sp) # 内核栈 32*8(sp) 处存储了原 sepc 寄存器的值, 将其读取到 t1ld t2, 2*8(sp) # 内核栈 32*8(sp) 处存储了原 sscratch 寄存器的值, 将其读取到 t2csrw sstatus, t0 # 将 t0中原 sstatus 寄存器的值读取到 sstatuscsrw sepc, t1 # 将 t0中原 sepc 寄存器的值读取到 sepccsrw sscratch, t2 # 将 t0中原 sscratch 寄存器的值读取到 sscratch\n\nL50-L56：为何跳过了 x2 和 x4？\n跳过x2是因为x2对应的用户栈指针保存到了sscratch寄存器, 不需要从内核栈中进行恢复\n跳过x4是因为并没有使用它, 所以无需恢复\n\nL60：该指令之后，sp 和 sscratch 中的值分别有什么意义？sp指向用户栈, sscratch指向内核栈\n__restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？sret后发生了状态切换, 执行该指令后, PC设置为 sepc 寄存器的值。sepc 存储着产生中断或异常前的指令地址，因此这实现了到原始代码的返回。\nL13：该指令之后，sp 和 sscratch 中的值分别有什么意义？csrrw sp, sscratch, sp\n\nsp, sscratch寄存器的内容被交换, sp保存了原sscratch中的内核栈指针, sscratch保存了原sp中的用户栈栈指针\n从 U 态进入 S 态是哪一条指令发生的？ecall指令\n对于任何中断，__alltraps 中都需要保存所有寄存器吗？你有没有想到一些加速 __alltraps 的方法？简单描述你的想法。在处理中断时，通常会在__alltraps函数中保存所有寄存器的状态，以确保在中断处理完成后能够正确恢复现场。然而，并非所有寄存器都需要保存，因为某些寄存器可能在中断处理过程中并不会被修改。\n一些加速__alltraps的方法包括：\n\n只保存和恢复中断处理过程中需要的寄存器。可以通过分析中断处理过程中的代码，确定哪些寄存器是必须保存的，而哪些是可以不保存的。\n使用内联汇编或者手动优化汇编代码，避免不必要的寄存器保存和恢复操作，从而减少中断处理的开销。\n将一些处理逻辑移到中断处理程序之外，减少__alltraps函数中的代码量，提高处理效率。\n\n总的来说，通过精心设计中断处理过程，只保存必要的寄存器状态，避免不必要的操作，并尽可能减少中断处理的复杂性，可以加速__alltraps函数的执行。希望这些想法对你有所帮助！如果有任何问题，请随时告诉我。\nlab3编程作业总结编程内容在TaskControl中增加相应的元素来记录需要的值//\tos/src/task/task.rspub struct TaskControlBlock &#123;    /// 任务状态    pub task_status: TaskStatus,    /// 任务上下文    pub task_cx: TaskContext,    /// 系统调用次数    pub syscall_times: [u32; MAX_SYSCALL_NUM],\t//lab3 adds    /// 启动时间    pub start_time: usize\t//lab3 addds&#125;\n\n其中start_time用来记录task第一次被调用的时间。\n在所有初始化和赋值TaskControl的函数增加对应域的初始化和赋值pub static ref TASK_MANAGER: TaskManager = &#123;\t……\tlet mut tasks = [TaskControlBlock &#123;            task_cx: TaskContext::zero_init(),            task_status: TaskStatus::UnInit,            syscall_times: [0; MAX_SYSCALL_NUM],            start_time: 0     &#125;; MAX_APP_NUM];     ……&#125;\n\n\n\n在task第一次被调度时为其start_time赋值这里采用了一个小trick，用start_time本身来做一个flag，当调度到其task时发现其start_time为0，则说明start_time为0，则说明该task第一次被调度，将start_time设计为当前时间，否则说明该task已经被调度过，不修改其start_time。\nfn run_next_task(&amp;self) &#123;        if let Some(next) = self.find_next_task() &#123;            let mut inner = self.inner.exclusive_access();            let current = inner.current_task;            inner.tasks[next].task_status = TaskStatus::Running;            if inner.tasks[next].start_time == 0&#123;        \tinner.tasks[next].start_time = get_time_us();            &#125;            ……    &#125;\n\n增加pub方法使得其它模块也能获取当前task的start_time和taskstatus，从而获取想要的信息。impl TaskManager &#123;    fn get_current_start_time(&amp;self)-&gt;usize&#123;        let inner=self.inner.exclusive_access();        let current=inner.current_task;        inner.tasks[current].start_time    &#125;     fn get_current_status(&amp;self)-&gt;TaskStatus&#123;        let inner=self.inner.exclusive_access();        let current=inner.current_task;        inner.tasks[current].task_status    &#125;    ……&#125;\n\npub fn get_current_start_time()-&gt;usize&#123;\tTASK_MANAGER.get_current_start_time()&#125;pub fn get_current_status()-&gt;TaskStatus&#123;\tTASK_MANAGER.get_current_status()&#125;\n\n增加syscall_times的记录和处理// os/src/task/mod.rsimpl TaskManager &#123;    ……    pub fn get_syscall_times(&amp;self)-&gt;[u32;500]&#123;        let inner=self.inner.exclusive_access();        let current=inner.current_task;        inner.tasks[current].syscall_times    &#125;    pub fn update_syscall_times(&amp;self,syscall_id: usize) &#123;        let mut inner = self.inner.exclusive_access();        let current = inner.current_task;        inner.tasks[current].syscall_times[syscall_id] += 1;    &#125;    ……&#125;……pub fn get_syscall_times()-&gt;[u32;500]&#123;\tTASK_MANAGER.get_syscall_times()&#125;pub fn update_syscall_times(syscall_id: usize) &#123;    TASK_MANAGER.update_syscall_times(syscall_id);&#125;\n\npub fn syscall(syscall_id: usize, args: [usize; 3]) -&gt; isize &#123;    update_syscall_times(syscall_id);&#125;\n\n实现系统调用sys_task_infopub fn sys_task_info(ti: *mut TaskInfo) -&gt; isize &#123;    trace!(&quot;kernel: sys_task_info&quot;);    unsafe&#123;        *ti = TaskInfo &#123;            status: get_current_status(),            syscall_times: get_syscall_times(),            time:(get_time_us()-get_current_start_time())/1000        &#125;;    &#125;    0&#125;\n\n运行结果\n问答作业正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容 (运行 Rust 两个 bad 测例 (ch2b_bad_*.rs) ) ， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。Rustsbi 版本为: 0.2.0-alpha.2\n出现报错:\n[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003c4, kernel killed it.[kernel] IllegalInstruction in application, kernel killed it.[kernel] IllegalInstruction in application, kernel killed it.\n\nch2b_bad_address.rs 由于除0错误触发异常退出 \nch2b_bad_instructions.rs 在用户态非法使用指令sret\nch2b_bad_register.rs 在用户态非法使用指令csrr\n请通过 gdb 跟踪或阅读源代码了解机器从加电到跳转到 0x80200000 的过程，并描述重要的跳转。回答内核是如何进入 S 态的？\n事实上进入 rustsbi (0x80000000) 之后就不需要使用 gdb 调试了。可以直接阅读 代码 。\n可以使用 Makefile 中的 make debug 指令。\n一些可能用到的 gdb 指令：\nx/10i 0x80000000 : 显示 0x80000000 处的10条汇编指令。\nx/10i $pc : 显示即将执行的10条汇编指令。\nx/10xw 0x80000000 : 显示 0x80000000 处的10条数据，格式为16进制32bit。\ninfo register: 显示当前所有寄存器信息。\ninfo r t0: 显示 t0 寄存器的值。\nbreak funcname: 在目标函数第一条指令处设置断点。\nbreak *0x80200000: 在 0x80200000 出设置断点。\ncontinue: 执行直到碰到断点。\nsi: 单步执行一条汇编指令。\n\n\n\nQemu 启动后 PC 被初始化为 0x1000 。我们可以检查一下 Qemu 的启动固件的内容：\n(gdb) x/10i $pc=&gt; 0x1000:  auipc   t0,0x00x1004:     addi    a1,t0,320x1008:     csrr    a0,mhartid0x100c:     ld      t0,24(t0)0x1010:     jr      t00x1014:     unimp0x1016:     unimp0x1018:     unimp0x101a:     0x80000x101c:     unimp\n\n Qemu 的固件仅包含 5 条指令，从 0x1014 开始都是数据，当数据为 0 的时候则会被反汇编为 unimp 指令。 0x101a 处的数据 0x8000 是能够跳转到 0x80000000 进入启动下一阶段的关键。在执行位于 0x1010 的指令之前，寄存器 t0 的值恰好为 0x80000000 ，随后通过 jr t0 便可以跳转到该地址。\n(gdb) si0x0000000000001004 in ?? ()(gdb) si0x0000000000001008 in ?? ()(gdb) si0x000000000000100c in ?? ()(gdb) si0x0000000000001010 in ?? ()(gdb) p/x $t01 = 0x80000000(gdb) si0x0000000080000000 in ?? ()\n\n可以看到，当位于 0x1010 的指令执行完毕后，下一条待执行的指令位于 RustSBI 的入口，也即 0x80000000 ，这意味着我们即将把控制权转交给 RustSBI 。\n(gdb) x/10i $pc=&gt; 0x80000000:      auipc   sp,0x280x80000004: mv      sp,sp0x80000008: lui     t0,0x40x8000000a: addi    t1,a0,10x8000000e: add     sp,sp,t00x80000010: addi    t1,t1,-10x80000012: bnez    t1,0x8000000e0x80000016: j       0x8001125a0x8000001a: unimp0x8000001c: addi    sp,sp,-48(gdb) si0x0000000080000004 in ?? ()(gdb) si0x0000000080000008 in ?? ()(gdb) si0x000000008000000a in ?? ()(gdb) si0x000000008000000e in ?? ()\n\n接下来我们检查控制权能否被移交给我们的内核：\n(gdb) b *0x80200000Breakpoint 1 at 0x80200000(gdb) cContinuing.Breakpoint 1, 0x0000000080200000 in ?? ()\n\nlab4编程作业总结编程内容重写 sys_get_time和sys_task_infopub fn sys_get_time(ts: *mut TimeVal, _tz: usize) -&gt; isize &#123;    trace!(&quot;kernel: sys_get_time&quot;);    let us = get_time_us();    unsafe &#123;        *ts = TimeVal &#123;            sec: us / 1_000_000,            usec: us % 1_000_000,        &#125;;    &#125;    0&#125;\n\n以sys_get_time为例，在原来的sys_get_time中，它传入的是一个TimeVal类型的指针，发起系统调用时是在用户态下传入的地址，在内核态下，该地址显然不再是传入的数据的位置，因此，我们只需要找到真实的地址即可。因此，我们只需要实现一个当前进程虚拟地址到物理地址的转换方法即可，一种实现方式为：\npub fn current_translated_physical_address(ptr:*const u8)-&gt;usize&#123;    let token = current_user_token();\tlet page_table=PageTable::from_token(token);\tlet mut va=VirtAddr::from(ptr as usize);\tlet mut vpn = va.floor();//va-&gt;virt page num\tlet ppn = page_table.translate(vpn).unwrap().ppn();\tPhysAddr::from(ppn).0+va.page_offset()&#125;\n\n由此可以得到的答案方法：\npub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -&gt; isize &#123;    let _us = get_time_us();    let ts=current_translated_physical_address(_ts as *const u8) as *mut TimeVal;    unsafe &#123;        *ts = TimeVal &#123;            sec: _us / 1_000_000,            usec: _us % 1_000_000,        &#125;;    &#125;    0&#125;pub fn sys_task_info(ti: *mut TaskInfo) -&gt; isize &#123;    let _ti = current_translated_physical_address(ti as *const u8) as *mut TaskInfo;    trace!(&quot;kernel: sys_task_info&quot;);    unsafe&#123;        *_ti = TaskInfo &#123;            status: get_current_status(),            syscall_times: get_syscall_times(),            time:(get_time_us()-get_current_start_time())/1000        &#125;;    &#125;    0&#125;\n\n实现 mmap和munmap我们观察到，MemorySet函数有如下方法：\npub fn insert_framed_area(    &amp;mut self,    start_va: VirtAddr,    end_va: VirtAddr,    permission: MapPermission,) &#123;    self.push(        MapArea::new(start_va, end_va, MapType::Framed, permission),        None,    );&#125;\n\n这个方法与我们要实现的函数参数基本一致，因此我们把它作为主体函数，同时，不要忘了对特殊情况进行排查，最终我们的实现方法如下：\nimpl MemorySet &#123;    pub fn mmap(&amp;mut self,start:usize,len:usize,port:usize)-&gt;isize&#123;        if start % PAGE_SIZE != 0         /* start need to be page aligned */         || port &amp; !0x7 != 0         /* other bits of port needs to be zero */         ||port &amp; 0x7 ==0         /* No permission set, meaningless */         ||start &gt;= MAXVA        /* mapping range should be an legal address */         &#123;return -1;&#125;        let vpnrange =VPNRange::new(VirtAddr::from(start).floor(),VirtAddr::from(start+len).ceil());        for vpn in vpnrange&#123;    \t\tif let Some(pte) = self.page_table.find_pte(vpn)&#123;    \t\t\tif pte.is_valid()&#123;    \t\t\t\treturn -1;    \t\t\t&#125;    \t\t&#125;    \t&#125;    \tlet mut map_prem = MapPermission::U;    \tif (port &amp; 1)!=0&#123;    \t\tmap_prem|=MapPermission::R;    \t&#125;    \tif (port &amp; 2)!=0&#123;    \t\tmap_prem|=MapPermission::W;    \t&#125;    \tif (port &amp; 4)!=0&#123;    \t\tmap_prem|=MapPermission::X;    \t&#125;\t\t  \t\t\tself.insert_framed_area(VirtAddr::from(start),VirtAddr::from(start+len),map_prem);    \t0    &#125;\n\n此后,由系统调用函数直接调用当前进程的MemorySet的该方法即可。\n同样，我们也可以在MemorySet中加入munmap方法：\nimpl MemorySet &#123;    pub fn munmap(&amp;mut self,start:usize,len:usize)-&gt;isize&#123;        if start &gt;= MAXVA || start % PAGE_SIZE != 0 &#123;return -1;&#125;    \tlet vpnrange = VPNRange::new(VirtAddr::from(start).floor(),VirtAddr::from(start+len).ceil());    \tfor vpn in vpnrange&#123;    \t\tlet pte = self.page_table.find_pte(vpn);    \t\tif pte.is_none() || !pte.unwrap().is_valid()&#123;    \t\t\treturn -1;    \t\t&#125;    \t&#125;    \tfor vpn in vpnrange&#123;    \t\tfor area in &amp;mut self.areas&#123;    \t\t\tif vpn &lt; area.vpn_range.get_end() &amp;&amp; vpn &gt;= area.vpn_range.get_start()&#123;    \t\t\t\tarea.unmap_one(&amp;mut self.page_table,vpn);    \t\t\t&#125;    \t\t&#125;    \t&#125;    \t0    &#125;\n\n第二个循环不仅取消了页表的映射，而且消除了对应的MapArea中对应的键值对，如此才能保证结构的一致性。\n运行结果\nlab5编程作业总结编程内容编程作业一:完成sys_spawn函数借鉴fork()和exec()的过程，我们可以看到spawn()只需要进行如下几步即可：\n\n根据exec()中的参数创建新的地址空间memory_set。\n创建新的TaskControlBlock，模仿fork()进行初始化赋值工作，除了把复制地址空间的操作修改为把地址空间赋值为memory_set。\n\npub fn sys_spawn(_path: *const u8) -&gt; isize &#123;    let current_task = current_task();    if current_task.is_none() &#123;        return -1;    &#125;    let current_task = current_task.unwrap();    let mut current_inner = current_task.inner_exclusive_access();    let token = current_inner.memory_set.token();    let path = translated_str(token, _path);    if let Some(data) = get_app_data_by_name(path.as_str()) &#123;        let child_block = Arc::new(TaskControlBlock::new(data));        let mut child_inner = child_block.inner_exclusive_access();        child_inner.parent = Some(Arc::downgrade(&amp;current_task));        current_inner.children.push(child_block.clone());        add_task(child_block.clone());        return child_block.pid.0 as isize;    &#125;    -1&#125;\n\n编程作业二：stride 调度算法\n在TCB中增加新字段\npub fn new(elf_data: &amp;[u8]) -&gt; Self &#123;\t\t……        let task_control_block = Self &#123;            pid: pid_handle,            kernel_stack,            inner: unsafe &#123;                UPSafeCell::new(TaskControlBlockInner &#123;                    trap_cx_ppn,                    base_size: user_sp,                    task_cx: TaskContext::goto_trap_return(kernel_stack_top),                    task_status: TaskStatus::Ready,                    memory_set,                    parent: None,                    children: Vec::new(),                    exit_code: 0,                    heap_bottom: user_sp,                    program_brk: user_sp,                    task_start_time: 0,                    task_syscall_times: [0; MAX_SYSCALL_NUM],                    stride: 0,                    priority: 16,                &#125;)            &#125;,        &#125;;    ……&#125;\n\n注意之后修改所有与TCB赋值和初始化有关的操作\n\n在每次 fetch 下一个 task 之前对这个队列中的 task 做检查， 找到最小的 stride。\n=pub fn fetch(&amp;mut self) -&gt; Option&lt;Arc&lt;TaskControlBlock&gt;&gt; &#123;        let mut min_index = 0;        let mut min_stride = 0x7FFF_FFFF;        for (idx, task) in self.ready_queue.iter().enumerate()\t\t  &#123;            let inner = task.inner.exclusive_access();            if inner.task_status == TaskStatus::Ready &#123;                if inner.stride &lt; min_stride &#123;                    min_stride = inner.stride;                    min_index = idx;                &#125;            &#125;        &#125;        if let Some(task) = self.ready_queue.get(min_index) &#123;            let mut inner = task.inner.exclusive_access();            inner.stride += BIG_STRIDE / inner.priority;        &#125;        self.ready_queue.remove(min_index)    &#125;&#125;\n\n运行截图lab3测例检查\nlab4测例检查\nlab5测例检查\n编程作业一:完成sys_spawn函数\n\n\n编程作业二：stride 调度算法\n\n\n\n1386266&#x2F;1292240 &#x3D; 0.995&lt;1.5 通过测例\n所有测例检查\n问答作业fork + exec 的一个比较大的问题是 fork 之后的内存页&#x2F;文件等资源完全没有使用就废弃了，针对这一点，有什么改进策略？Answer:\n\n使用 Copy-on-Write（写时复制）技术：在 fork 时，父子进程共享相同的内存页，直到其中一个进程试图对共享内存进行写操作时，才会复制出一个新的内存页。这样可以避免不必要的内存复制，减少资源浪费。\n\n非阻塞地执行 fork 和 exec：在执行 fork 和 exec 时，可以考虑使用异步方式，即父进程继续执行，而子进程在需要时再进行资源初始化和 exec 调用。这样可以避免不必要的资源浪费，提高系统的资源利用率。\n\n考虑使用其他机制替代 fork 和 exec：有些情况下，可以考虑使用线程或者其他机制来实现类似的功能，避免不必要的资源复制和浪费。\n\n\n[选做，不占分]其实使用了题(1)的策略之后，fork + exec 所带来的无效资源的问题已经基本被解决了，但是近年来 fork 还是在被不断的批判，那么到底是什么正在”杀死”fork？可以参考 论文 。Answer:\nfork 和其他的操作不正交,也就是 os 每增加一个功能,都要改 fork, 这导致新功能开发困难,设计受限.有些和硬件相关的甚至根本无法支持 fork.\nfork 得到的父子进程可能产生共享资源的冲突；\n子进程继承父进程，如果父进程处理不当，子进程可以找到父进程的安全漏洞进而威胁父进程；\n还有比如 fork 必须要虚存, SAS 无法支持等等.\n请阅读下列代码，并分析程序的输出，假定不发生运行错误，不考虑行缓冲：int main()&#123;    int val = 2;    printf(&quot;%d&quot;, 0);    int pid = fork();    if (pid == 0) &#123;        val++;        printf(&quot;%d&quot;, val);    &#125; else &#123;        val--;        printf(&quot;%d&quot;, val);        wait(NULL);    &#125;    val++;    printf(&quot;%d&quot;, val);    return 0;&#125;\n\n如果 fork() 之后主程序先运行，则结果如何？如果 fork() 之后 child 先运行，则结果如何？\nAnswer:\n\n主程序先运行:01342\nchild 先运行:03412\n\n[选做，不占分] 更进一步，如果给出一个 &amp;&amp; || 的序列，如何设计一个程序来得到答案？Anser:\n如果需要设计一个程序以及给定一个 &amp;&amp; || 的序列，来计算输出的数量，可以考虑使用递归的方式实现。每次调用递归函数时，根据当前操作符是 &amp;&amp; 还是 ||，分别判断左右子表达式的结果，从而更新当前表达式的计算结果。通过递归调用，可以一步步计算出最终的结果，得到预期的输出数量。\n// 使用 enum 来表示操作符的类型enum Operator &#123; AND = 0, OR = 1 &#125;;// 递归计算并输出 &#x27;A&#x27; 的数量int evaluateExpression(int* sequence, int start, int end) &#123;    if (start == end) &#123;        return sequence[start];    &#125;    int op = sequence[start];  // 当前操作符    int countA = 0;    if (op == AND) &#123;        // 递归计算左右子表达式        int left = evaluateExpression(sequence, start + 1, end);        int right = evaluateExpression(sequence, left + 1, end);        // 计算并返回 &#x27;A&#x27; 的数量        countA = left + right;    &#125; else if (op == OR) &#123;        // 递归计算左子表达式        int left = evaluateExpression(sequence, start + 1, end);        // 递归计算右子表达式        int right = evaluateExpression(sequence, left + 1, end);        // 计算并返回 &#x27;A&#x27; 的数量        countA = left &gt; right ? left : right;    &#125;    return countA;&#125;int main() &#123;    int sequence[] = &#123;AND, AND, OR, AND, OR, AND&#125;;    int result = evaluateExpression(sequence, 0, 7);        printf(&quot;Total count of &#x27;A&#x27;: %d\\n&quot;, result);        return 0;&#125;\n\nstride 算法深入stride 算法原理非常简单，但是有一个比较大的问题。例如两个 pass &#x3D; 10 的进程，使用 8bit 无符号整形储存  stride， p1.stride &#x3D; 255, p2.stride &#x3D; 250，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。\n实际情况是轮到 p1 执行吗？为什么？Answer: 实际情况还是p2执⾏，因为8位⽆符号整型取值范围是0-255，如果p2.stride加了10溢出了，变成了4，对⽐的时候还是⽐p1.stride⼩，所以还是p2执⾏。\n我们之前要求进程优先级 &gt;&#x3D; 2 其实就是为了解决这个问题。可以证明，在不考虑溢出的情况下, 在进程优先级全部 &gt;&#x3D; 2 的情况下，如果严格按照算法执行，那么 STRIDE_MAX – STRIDE_MIN &lt;&#x3D; BigStride &#x2F; 2。\n为什么？尝试简单说明（传达思想即可，不要求严格证明）。**Answer:**因为优先级全部⼤于等于2，所以pass⼀定是⼩于⼆分之⼀的BigStride。在不考虑溢出的情况下，假设a进程的stride⼩于b进程，且⼆者差⼩于⼆分之⼀BigStride，则a进程的stride + pass⼀定⼤于b，且新的差不会⼤于⼆分之⼀BigStride。开始时⼆者stride都为零，经过⼀次调度后满⾜上述情况，所以如此迭代下去，如果严格按照算法执⾏，那么STIDE_MAX-STRIDE_MIN&lt;&#x3D;BigStride&#x2F;2成⽴。\n已知以上结论，考虑溢出的情况下，我们可以通过设计 Stride 的比较接口，结合 BinaryHeap 的 pop 接口可以很容易的找到真正最小的 Stride。\n请补全如下 partial_cmp 函数（假设永远不会相等） use core::cmp::Ordering; struct Stride(u64); impl PartialOrd for Stride &#123;  fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; &#123;     // ...  &#125;&#125; impl PartialEq for Person &#123;  fn eq(&amp;self, other: &amp;Self) -&gt; bool &#123;     false  &#125;&#125;\n\n Answer:\n  fn partial_cmp(&amp;self, other: &amp;Self) -&gt; Option&lt;Ordering&gt; &#123;      if self.0 &lt; other.0 &#123;          if (other.0 - self.0) &gt; (BigStride / 2) &#123;              Some(Ording::Greater)       &#125; else &#123;           Some(Ording::Less)       &#125;      &#125; else if self.0 &gt; other.0 &#123;          if (self.0 - other.0) &gt; (BigStride / 2) &#123;              Some(Ording::Less)       &#125; else &#123;           Some(Ording::Greater)      &#125;   &#125;&#125;\n\n例如使用 8 bits 存储 stride, BigStride = 255, 则:\n\n- (125 &lt; 255) == false\n- (129 &lt; 255) == true\n\n","categories":["操作系统及安全"],"tags":["实验"]},{"title":"一些有用的博文或项目","url":"/2025/04/07/%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E5%8D%9A%E6%96%87%E6%88%96%E9%A1%B9%E7%9B%AE/","content":"写一些我觉得很有用的博文和项目等等，不定期更新。\nNote:由于我使用的是windows系统所以一些博文和项目中的内容可能不适用于其它操作系统。\n优质博文\n如何搭建个人博客网站：https://xiaofucode.com/guide/interview/tools/%E6%89%8B%E6%8A%8A%E6%89%8B%EF%BC%8C%E6%95%99%E4%BD%A0%E5%85%8D%E8%B4%B9%E6%90%AD%E4%B8%80%E4%B8%AA%E9%AB%98%E9%80%BC%E6%A0%BC%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2.html\n\n搭建完成后如果使用的是Next主题关于配置可以参考我的博文hexo的使用方法(在Next主题下)\n\n\nAlist安装教程：https://blog.csdn.net/Zhudi1145/article/details/140519215?ops_request_misc=%257B%2522request%255Fid%2522%253A%252262bd8fa17d9ae93175167c34a513891a%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=62bd8fa17d9ae93175167c34a513891a&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-13-140519215-null-null.142\n\n\n优质项目\n如何在终端实现翻译功能：https://github.com/Karmenzind/kd\nGo语言实现的简洁好用的命令行词典，跨平台、易于安装、持续维护更新\n\n如何在终端和chatgpt等大模型交流：https://github.com/Aider-AI/aider\n安装，配置以及使用可依据https://aider.chat/docs/llms.html\n\n实现好看、好用的终端：因为我是windows系统所以我用的是nushell，Oh My Zsh需要借助WSL2，看起来比较麻烦，不过也是可以的，linux系统还是推荐Oh My Zsh。\n\nwindows系统安装好后如果想要设置为默认终端或者想在windows终端上添加nushell可以参考微软官方文档https://learn.microsoft.com/zh-cn/windows/terminal/install\n\n\n把各大网盘聚合起来的网盘挂载工具：Alist\n关于如何安装可以参考优质博文中的Alist安装教程。\n\n如果要获取免费API的话比较推荐Get API key | Google AI Studio\n还可以使用github项目GPT_API_Free，但是效果没有Google AI Studio的好,主要是一些上传文件之类的功能受限。\n\n\n科学上网：直接在github上搜就可以了，我有一个比较好用而且免费的订阅节点，但是因为是很久以前配置的，现在已经找不到出处了，但是应该是在github上找到的。\n\n如果你是CSU的学生并且在选课的时候总是手慢并为此苦恼的话，推荐一个本校学生开发的选课脚本：https://github.com/Rui-li023/CSUAutoSelect\n\n\n优质软件及其破解\nJebrains全家桶(对我来讲professional版本最好的地方就是增加了数据库工具，测试的时候非常方便)：淘宝上有一个一键破解软件，一块钱，可以试试。\n\n【淘宝】99%买家好评 https://e.tb.cn/h.65FGg8hXyNyve4G?tk=7ZwNeBo7HSx MF168 「pycharm2025永久激活码2099年 jetbrains全家桶激活 idea  cloin」点击链接直接打开 或者 淘宝搜索直接打开\n\n\n\nmarkdown：https://github.com/markyin0707/typora-activation，亲测有效。\n\n\n优质网站一些耳熟能详的网站比如菜鸟驿站、bilibili、stackoverflow，我觉得大家应该都知道所以就不收录了。\n\n知识星球：可以在上面找实战项目。\n漫画资源网站，资源很全，完全免费：https://mox.moe/\n\n待使用的项目放一些我没使用过但是很感兴趣以及将来会使用的项目,大多数都是从HelloGitHub上找到的，我觉得这个项目还是蛮有意思的。\n\n一款结构化的 Markdown 引擎，支持 Go 和 JavaScript：Lute\n电脑分屏工具,你可以在主显示屏)写代码，左边显示器看文档、查资料，并通过窗口固定在屏幕的左右两侧。：Slate\n\n关于浏览器推荐Google Chrome，因为有一次我在firefox上拿某一网站cookie值用来配置，结果一直显示出错，后来用Google Chrome立马就成功了。\n关于切换默认浏览器可以参考微软官方文档https://support.microsoft.com/zh-cn/windows/%E5%9C%A8-windows-%E4%B8%AD%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E5%BA%94%E7%94%A8-e5d82cad-17d1-c53b-3505-f10a32e1894d\n免费的AI工具\ndeepseek：网站免费，API付费。\ncodegeex：codegeex免费，codegeex还提供免费的API，还是不错的。\n\n","categories":["杂谈"]},{"title":"我的电脑的磁盘设置","url":"/2025/04/06/%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E7%9A%84%E7%A3%81%E7%9B%98%E8%AE%BE%E7%BD%AE/","content":"G盘(存储github上的代码和博客网站)：code代码盘，blog博客盘\nF盘：installation文件夹存放软件安装包，app文件夹存放软件，image文件夹放镜像文件\nD盘：中转站\nC盘：系统文件\n","categories":["杂谈"]},{"title":"数据库实验","url":"/2025/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C/","content":"实验项目一CREATE DATABASE 实验项目一;USE 实验项目一;\n\n创建后面给出的这6个表（20分）-- 读者信息表CREATE TABLE 读者信息表 (    借书证号 CHAR(8) PRIMARY KEY,    姓名 VARCHAR(50),    性别 ENUM(&#x27;女&#x27;, &#x27;男&#x27;),    出生日期 DATE,    借书量 INT DEFAULT 0,    工作单位 VARCHAR(100),    电话 CHAR(11),    电子邮件 VARCHAR(50));  INSERT INTO 读者信息表 (借书证号, 姓名, 性别, 出生日期, 借书量, 工作单位, 电话, 电子邮件)VALUES    (&#x27;29307142&#x27;, &#x27;张晓露&#x27;, &#x27;女&#x27;, &#x27;1989-02-01&#x27;, 2, &#x27;管理信息系&#x27;, &#x27;85860126&#x27;, &#x27;zxl@163.com&#x27;),    (&#x27;36405216&#x27;, &#x27;李阳&#x27;, &#x27;男&#x27;, &#x27;1988-12-26&#x27;, 1, &#x27;航海系&#x27;, &#x27;85860729&#x27;, &#x27;ly@sina.com.cn&#x27;),    (&#x27;28308208&#x27;, &#x27;王新全&#x27;, &#x27;男&#x27;, &#x27;1988-04-25&#x27;, 1, &#x27;人文艺术系&#x27;, &#x27;85860618&#x27;, &#x27;wxq@yahoo.cn&#x27;),    (&#x27;16406236&#x27;, &#x27;张继刚&#x27;, &#x27;男&#x27;, &#x27;1989-08-18&#x27;, 1, &#x27;轮机工程系&#x27;, &#x27;85860913&#x27;, &#x27;zjg@163.com&#x27;);INSERT INTO readerMessage (借书证号, 姓名, 性别, 出生日期,  工作单位, 电话, 电子邮件)VALUES\t(&#x27;16406247&#x27;, &#x27;顾一帆&#x27;, &#x27;男&#x27;, &#x27;1981-12-30&#x27;, &#x27;轮机工程系&#x27;, &#x27;85860916&#x27;, &#x27;gyf@yahoo.cn&#x27;);\n\n\n\n\n借书证号\n姓名\n性别\n出生日期\n借书量\n工作单位\n电话\nE-mail\n\n\n\n29307142\n张晓露\n女\n1989-02-1\n2\n管理信息系\n85860126\nzxl@163.com\n\n\n36405216\n李阳\n男\n1988-12-26\n1\n航海系\n85860729\nly@sina.com.cn\n\n\n28308208\n王新全\n男\n1988-04-25\n1\n人文艺术系\n85860618\nwxq@yahoo.cn\n\n\n16406236\n张继刚\n男\n1989-08-18\n1\n轮机工程系\n85860913\nzjg@163.com\n\n\n16406247\n顾一帆\n男\n1981-12-30\n\n轮机工程系\n85860916\ngyf@yahoo.cn\n\n\n-- 借还明细表CREATE TABLE 借还明细表 (    借书证号 VARCHAR(10),    图书编号 VARCHAR(10),    借还状态 ENUM(&#x27;还&#x27;,&#x27;借&#x27;),    借书日期 DATE,    还书日期 DATE,    数量 INT,    工号 VARCHAR(10),    CONSTRAINT check_borrow_date CHECK (借书日期 &lt;= &#x27;2024-12-31&#x27;),    FOREIGN KEY (借书证号) REFERENCES 读者信息表(借书证号));INSERT INTO 借还明细表 (借书证号, 图书编号, 借还状态, 借书日期, 还书日期, 数量, 工号)VALUES    (&#x27;29307142&#x27;, &#x27;07108667&#x27;, &#x27;还&#x27;, &#x27;2008-03-28&#x27;, &#x27;2008-04-14&#x27;, 1, &#x27;002016&#x27;),    (&#x27;29307142&#x27;, &#x27;99011818&#x27;, &#x27;借&#x27;, &#x27;2008-04-27&#x27;, NULL, 1, &#x27;002016&#x27;),    (&#x27;36405216&#x27;, &#x27;07410802&#x27;, &#x27;借&#x27;, &#x27;2008-04-27&#x27;, NULL, 1, &#x27;002018&#x27;),    (&#x27;29307142&#x27;, &#x27;07410298&#x27;, &#x27;借&#x27;, &#x27;2008-04-28&#x27;, NULL, 1, &#x27;002018&#x27;),    (&#x27;36405216&#x27;, &#x27;00000746&#x27;, &#x27;还&#x27;, &#x27;2008-04-29&#x27;, &#x27;2008-05-09&#x27;, 1, &#x27;002016&#x27;),    (&#x27;28308208&#x27;, &#x27;07410139&#x27;, &#x27;借&#x27;, &#x27;2008-05-10&#x27;, NULL, 1, &#x27;002019&#x27;),    (&#x27;16406236&#x27;, &#x27;07410139&#x27;, &#x27;借&#x27;, &#x27;2008-05-11&#x27;, NULL, 1, &#x27;002017&#x27;);\n\n\n\n\n借书证号\n图书编号\n借&#x2F;还\n借书日期\n还书日期\n数量\n工号\n\n\n\n29307142\n07108667\n还\n2008-03-28\n2008-04-14\n1\n002016\n\n\n29307142\n99011818\n借\n2008-04-27\n\n1\n002016\n\n\n36405216\n07410802\n借\n2008-04-27\n\n1\n002018\n\n\n29307142\n07410298\n借\n2008-04-28\n\n1\n002018\n\n\n36405216\n00000746\n还\n2008-04-29\n2008-05-09\n1\n002016\n\n\n28308208\n07410139\n借\n2008-05-10\n\n1\n002019\n\n\n16406236\n07410139\n借\n2008-05-11\n\n1\n002017\n\n\n-- 图书类别CREATE TABLE 图书类别表 (\t类别号 CHAR(10) ,\t图书类别 CHAR(10));INSERT INTO 图书类别表 (类别号,图书类别)VALUES\t(&#x27;H31&#x27;,&#x27;英语&#x27;),\t(&#x27;I267&#x27;,&#x27;当代作品&#x27;),\t(&#x27;TP312&#x27;,&#x27;程序语言&#x27;),\t(&#x27;TP393&#x27;,&#x27;计算机网络&#x27;),\t(&#x27;U66&#x27;,&#x27;船舶工程&#x27;);\n\n\n\n\n类别号\n图书类别\n\n\n\nH31\n英语\n\n\nI267\n当代作品\n\n\nTP312\n程序语言\n\n\nTP393\n计算机网络\n\n\nU66\n船舶工程\n\n\n-- 图书借阅表CREATE TABLE 图书借阅表(    图书编号 VARCHAR(10),    图书名称 CHAR(20),    借书证号 CHAR(8),    借出日期 DATE,    归还日期 DATE,    库存数 INT,    CONSTRAINT check_borrow_date CHECK (借出日期 &lt;= &#x27;2024-12-31&#x27;),    FOREIGN KEY (图书编号) REFERENCES 图书明细表(图书编号),    FOREIGN KEY (借书证号) REFERENCES 读者信息表(借书证号));INSERT INTO 图书借阅表(图书编号,图书名称,借书证号,借出日期,库存数)VALUES\t(&#x27;99011818&#x27;,&#x27;文化苦旅&#x27;,&#x27;29307142&#x27;,&#x27;2008-04-27&#x27;,14),\t(&#x27;07410802&#x27;,&#x27;航海英语&#x27;,&#x27;36405216&#x27;,&#x27;2008-04-27&#x27;,24),\t(&#x27;07410298&#x27;,&#x27;C++程序设计语言&#x27;,&#x27;29307142&#x27;,&#x27;2008-04-28&#x27;,14),\t(&#x27;07410139&#x27;,&#x27;艺海潮音&#x27;,&#x27;28308208&#x27;,&#x27;2008-05-10&#x27;,18),\t(&#x27;07410139&#x27;,&#x27;艺海潮音&#x27;,&#x27;16406236&#x27;,&#x27;2008-05-11&#x27;,17);\n\n\n\n\n图书编号\n图书名称\n借书证号\n借出日期\n归还日期\n库存数\n\n\n\n99011818\n文化苦旅\n29307142\n2008-04-27\n\n14\n\n\n07410802\n航海英语\n36405216\n2008-04-27\n\n24\n\n\n07410298\nC++程序设计语言\n29307142\n2008-04-28\n\n14\n\n\n07410139\n艺海潮音\n28308208\n2008-05-10\n\n18\n\n\n07410139\n艺海潮音\n16406236\n2008-05-11\n\n17\n\n\n-- 工作人员CREATE TABLE 工作人员 (    工号 VARCHAR(10) PRIMARY KEY,    姓名 VARCHAR(50),    性别 VARCHAR(10),    出生日期 DATE,    联系电话 VARCHAR(20),    E_mail VARCHAR(50), ,    CONSTRAINT check_birth_date CHECK (出生日期 &lt;= &#x27;2024-12-31&#x27;));INSERT INTO 工作人员 (工号, 姓名, 性别, 出生日期, 联系电话, E_mail)VALUES    (&#x27;002016&#x27;, &#x27;周学飞&#x27;, &#x27;男&#x27;, &#x27;1971-05-03&#x27;, &#x27;85860715&#x27;, &#x27;zxf@163.com&#x27;),    (&#x27;002017&#x27;, &#x27;李晓静&#x27;, &#x27;女&#x27;, &#x27;1979-09-15&#x27;, &#x27;85860716&#x27;, &#x27;lj@163.com&#x27;),    (&#x27;002018&#x27;, &#x27;顾彬&#x27;, &#x27;男&#x27;, &#x27;1972-04-25&#x27;, &#x27;85860717&#x27;, &#x27;gb@yahoo.cn&#x27;),    (&#x27;002019&#x27;, &#x27;陈欣&#x27;, &#x27;女&#x27;, &#x27;1968-11-03&#x27;, &#x27;85860718&#x27;, &#x27;cx@sina.com.cn&#x27;);\n\n\n\n\n工号\n姓名\n性别\n出生日期\n联系电话\nE-mail\n\n\n\n002016\n周学飞\n男\n1971-05-03\n85860715\nzxf@163.com\n\n\n002017\n李晓静\n女\n1979-09-15\n85860716\nlj@163.com\n\n\n002018\n顾彬\n男\n1972-04-25\n85860717\ngb@yahoo.cn\n\n\n002019\n陈欣\n女\n1968-11-03\n85860718\ncx@sina.com.cn\n\n\n-- 图书明细表 CREATE TABLE 图书明细表 (    类别号 VARCHAR(10),    图书编号 VARCHAR(10) PRIMARY KEY,    图书名称 VARCHAR(50),    作者 VARCHAR(50),    出版社 VARCHAR(50),    定价 DECIMAL(10, 2),    购进日期 DATE,    购入数 INT,    复本数 INT,    库存数 INT);INSERT INTO 图书明细表 (类别号, 图书编号, 图书名称, 作者, 出版社, 定价, 购进日期, 购入数, 复本数, 库存数)VALUES    (&#x27;I267&#x27;, &#x27;99011818&#x27;, &#x27;文化苦旅&#x27;, &#x27;余秋雨&#x27;, &#x27;知识出版社&#x27;, 16, &#x27;2000-03-19&#x27;, 8, 15, 14),    (&#x27;TP312&#x27;, &#x27;00000476&#x27;, &#x27;Delphi高级开发指南&#x27;, &#x27;坎图&#x27;, &#x27;电子工业出版社&#x27;, 80, &#x27;2000-03-19&#x27;, 15, 15, 15),    (&#x27;U66&#x27;, &#x27;01058589&#x27;, &#x27;船舶制造基础&#x27;, &#x27;杨敏&#x27;, &#x27;国防工业出版社&#x27;, 19, &#x27;2001-07-15&#x27;, 20, 20, 20),    (&#x27;I267&#x27;, &#x27;07410139&#x27;, &#x27;艺海潮音&#x27;, &#x27;李叔&#x27;, &#x27;江苏文艺出版社&#x27;, 19, &#x27;2007-04-12&#x27;, 15, 20, 18),    (&#x27;TP312&#x27;, &#x27;07410298&#x27;, &#x27;C++程序设计&#x27;, &#x27;成颖&#x27;, &#x27;东南大学出版社&#x27;, 38, &#x27;2007-05-08&#x27;, 10, 15, 14),    (&#x27;H31&#x27;, &#x27;07410802&#x27;, &#x27;航海英语&#x27;, &#x27;陈宏权&#x27;, &#x27;武汉工业大学出版社&#x27;, 42, &#x27;2007-10-20&#x27;, 25, 25, 24),    (&#x27;H31&#x27;, &#x27;07108667&#x27;, &#x27;大学英语学习辅导&#x27;, &#x27;姜丽蓉&#x27;, &#x27;北京理工大学出版社&#x27;, 23.5, &#x27;2008-02-06&#x27;, 25, 25, 25),    (&#x27;TP393&#x27;, &#x27;07410810&#x27;, &#x27;网络工程实用教程&#x27;, &#x27;汪新民&#x27;, &#x27;北京大学出版社&#x27;, 34.8, &#x27;2008-08-21&#x27;, 10, 15, 15);\n\n\n\n\n类别号\n图书编号\n图书名称\n作者\n出版社\n定价\n购进日期\n购入数\n复本数\n库存数\n\n\n\nI267\n99011818\n文化苦旅\n余秋雨\n知识出版社\n16\n2000-03-19\n8\n15\n14\n\n\nTP312\n00000476\nDelphi高级开发指南\n坎图\n电子工业出版社\n80\n2000-03-19\n15\n15\n15\n\n\nU66\n01058589\n船舶制造基础\n杨敏\n国防工业出版社\n19\n2001-07-15\n20\n20\n20\n\n\nI267\n07410139\n艺海潮音\n李叔\n江苏文艺出版社\n19\n2007-04-12\n15\n20\n18\n\n\nTP312\n07410298\nC++程序设计\n成颖\n东南大学出版社\n38\n2007-05-08\n10\n15\n14\n\n\nH31\n07410802\n航海英语\n陈宏权\n武汉工业大学出版社\n42\n2007-10-20\n25\n25\n24\n\n\nH31\n07108667\n大学英语学习辅导\n姜丽蓉\n北京理工大学出版社\n23.5\n2008-02-06\n25\n25\n25\n\n\nTP393\n07410810\n网络工程实用教程\n汪新民\n北京大学出版社\n34.8\n2008-08-21\n10\n15\n15\n\n\n1)用不同的方法创建约束；2）查看和删除约束；(3）创建、删除默认和规则 (3*5分)用不同的方法创建约束(5分)\n在表定义时直接添加约束&amp;&amp;使用 CONSTRAINT 关键字命名约束\n\n-- 借还明细表CREATE TABLE 借还明细表 (    借书证号 VARCHAR(10) NOT NULL,    图书编号 VARCHAR(10),    借还状态 ENUM(&#x27;还&#x27;,&#x27;借&#x27;),    借书日期 DATE,    还书日期 DATE,    数量 INT,    工号 VARCHAR(10),    CONSTRAINT check_borrow_date CHECK (借书日期 &lt;= &#x27;2024-12-31&#x27;),    FOREIGN KEY (图书编号) REFERENCES 图书明细表(图书编号),    FOREIGN KEY (借书证号) REFERENCES 读者信息表(借书证号));-- 图书明细表CREATE TABLE 图书明细表 (    类别号 VARCHAR(10),    图书编号 VARCHAR(10) PRIMARY KEY,    图书名称 VARCHAR(50),    作者 VARCHAR(50),    出版社 VARCHAR(50),    定价 DECIMAL(10, 2),    购进日期 DATE,    购入数 INT,    复本数 INT,    库存数 INT);-- 读者信息表CREATE TABLE 读者信息表 (    借书证号 CHAR(8) PRIMARY KEY,    姓名 VARCHAR(50),    性别 ENUM(&#x27;女&#x27;, &#x27;男&#x27;),    出生日期 DATE,    借书量 INT,    工作单位 VARCHAR(100),    电话 CHAR(11),    电子邮件 VARCHAR(50));  \n\n\n使用ALTER TABLE 语句添加约束\n\nALTER TABLE 读者信息表ADD CONSTRAINT check_birth_date CHECK (出生日期 &lt;= &#x27;2024-12-31&#x27;);\n\nALTER TABLE 读者信息表 ADD CONSTRAINT RMP PRIMARY KEY (借书证号);\n\nALTER TABLE 借还明细表ADD CONSTRAINT fk_借书证号 FOREIGN KEY (借书证号) REFERENCES 读者信息表(借书证号);\n\n用不同的方法查看和删除约束（5分）查看约束：使用DESCRIBE命令查看表结构，约束信息通常会显示在表结构描述中。\nDESCRIBE 表名;mysql&gt; DESCRIBE 借还明细表;+----------+-------------+------+-----+---------+-------+| Field    | Type        | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| 借书证号 | varchar(10) | YES  | MUL | NULL    |       || 图书编号 | varchar(10) | YES  |     | NULL    |       || 借还状态 | varchar(5)  | YES  |     | NULL    |       || 借书日期 | date        | YES  |     | NULL    |       || 还书日期 | date        | YES  |     | NULL    |       || 数量     | int         | YES  |     | NULL    |       || 工号     | varchar(10) | YES  |     | NULL    |       |+----------+-------------+------+-----+---------+-------+\n\n使用SHOW CREATE TABLE命令查看表的创建语句，约束信息会包含在创建语句中。\nSHOW CREATE TABLE 表名;| 借还明细表 | CREATE TABLE `借还明细表` (  `借书证号` varchar(10) DEFAULT NULL,  `图书编号` varchar(10) DEFAULT NULL,  `借还状态` varchar(5) DEFAULT NULL,  `借书日期` date DEFAULT NULL,  `还书日期` date DEFAULT NULL,  `数量` int DEFAULT NULL,  `工号` varchar(10) DEFAULT NULL,  KEY `fk_借书证号` (`借书证号`),  CONSTRAINT `fk_借书证号` FOREIGN KEY (`借书证号`) REFERENCES `读者信息表` (`借书证号`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |\n\n查看某个约束的具体信息：\nSELECT *FROM information_schema.table_constraintsWHERE table_name = &#x27;借还明细表&#x27; AND table_schema = &#x27;实验项目一&#x27;;\n\n删除约束：使用ALTER TABLE语句删除约束。\nALTER TABLE 读者信息表DROP CONSTRAINT check_birth_date;\n\nALTER TABLE 借还明细表 DROP FOREIGN KEY fk_借书证号;ALTER TABLE 读者信息表DROP PRIMARY KEY;\n\n用不同的方法创建、删除默认值和规则 （5分）创建默认值：在CREATE TABLE语句中定义列时指定默认值。\nCREATE TABLE 读者信息表 (    借书证号 CHAR(8) PRIMARY KEY,    姓名 VARCHAR(50),    性别 ENUM(&#x27;女&#x27;, &#x27;男&#x27;),    出生日期 DATE,    借书量 INT DEFAULT 0,    工作单位 VARCHAR(100),    电话 CHAR(11),    电子邮件 VARCHAR(50));  \n\n使用ALTER TABLE语句添加默认值。\nALTER TABLE 读者信息表 MODIFY COLUMN 借书量 INT DEFAULT 0;\n\n删除默认值：使用ALTER TABLE语句删除列的默认值。\nALTER TABLE 读者信息表 ALTER COLUMN 借书量 DROP DEFAULT;\n\n使用ALTER TABLE语句修改列的默认值。\nALTER TABLE 读者信息表 ALTER COLUMN 借书量 SET DEFAULT NULL;\n\n创建规则：-- 创建规则CREATE RULE rule_name AS ON INSERT TO table_nameWHERE conditionDO INSTEAD INSERT INTO table_name VALUES (value1, value2, ...);\n\n在上面的示例中，您可以使用 CREATE RULE 语句来创建规则，规则会在满足条件时执行指定的操作。\n删除规则：-- 删除规则DROP RULE rule_name ON table_name;\n\n在上面的示例中，您可以使用 DROP RULE 语句来删除表上的规则。\n1）掌握主键约束的特点和用法；2）掌握惟一性约束的用法；3）掌握默认约束和默认对象的用法；4）掌握CHECK约束和规则对象的用法；5）掌握利用主键与外键约束实现参照完整性的方法(5*5分)。掌握主键约束的特点和用法（5分）主键约束是关系型数据库中非常重要的概念，它具有以下特点和用法：\n\n唯一性：主键约束要求表中的每一行数据都具有唯一的主键值。这意味着主键值在整个表中必须是唯一的，不允许重复。\n\n非空性：主键列的值不能为 NULL。主键值必须在每一行中存在且不为空。\n\n数据完整性：主键约束确保了表中数据的完整性和一致性。通过主键约束，可以确保每一行数据都可以唯一地被标识和访问。\n\n索引：主键约束会自动创建索引，以加速对主键列的查询和访问。这样可以提高数据检索的效率。\n\n外键关系：主键约束常用于定义表与表之间的关系。在另一个表中，可以通过外键约束引用主键，建立表与表之间的关联关系。\n\n\n用法：\n\n在创建表时定义主键约束：可以在 CREATE TABLE 语句中通过 PRIMARY KEY 关键字定义主键约束。\n修改表结构时添加主键约束：可以使用 ALTER TABLE 语句来添加主键约束。\n主键的选择：主键通常选择具有唯一性且不会经常变化的列作为主键，例如自增长的整数列。\n主键的作用：主键可以作为表中每一行数据的唯一标识符，便于数据的检索、更新和删除操作。\n\n总之，主键约束是数据库设计中非常重要的概念，它确保了数据的完整性和唯一性，并在数据库操作中起着重要的作用。\n掌握惟一性约束的用法（5分）惟一性约束（Unique Constraint）是关系型数据库中的一种约束，用于确保表中某个列或一组列的取值在整个表中是唯一的。惟一性约束与主键约束类似，但不要求被约束的列是主键，可以是任意列或组合列。\n以下是关于惟一性约束的用法：\n\n定义唯一性约束：在创建表时，可以使用 UNIQUE 关键字定义唯一性约束。语法如下：\n\nCREATE TABLE 表名 (    列名1 数据类型,    列名2 数据类型,    ...    UNIQUE (列名1, 列名2, ...));\n\n\n添加唯一性约束：在已有表中添加唯一性约束，可以使用 ALTER TABLE 语句。语法如下：\n\nALTER TABLE 表名 ADD CONSTRAINT 约束名 UNIQUE (列名);\n\n\n唯一性约束的作用：\n\n确保表中的某列或组合列的取值是唯一的，不允许重复。\n可以用于定义候选键（Candidate Key），即在主键外的另一个唯一标识符。\n可以提高数据的完整性和准确性，避免数据重复和冲突。\n\n\n唯一性约束与主键的区别：\n\n主键约束要求被约束的列是唯一的且不为空，而唯一性约束只要求唯一性，允许 NULL 值。\n表只能有一个主键，但可以有多个唯一性约束。\n\n\n唯一性约束的使用场景：\n\n用于确保某列或组合列的取值是唯一的，如用户名、邮箱等。\n用于定义候选键，提供多个唯一标识符供查询和关联。\n\n\n\n总之，唯一性约束是一种重要的数据库约束，用于确保数据的唯一性和完整性。在设计数据库时，根据实际需求考虑是否需要添加唯一性约束来提高数据的质量和准确性。\n掌握默认约束和默认对象的用法（5分）默认约束（Default Constraint）和默认对象（Default Object）是关系型数据库中用于指定列默认值的概念。它们的主要作用是在插入数据时，如果未显式提供该列的值，则自动使用默认值。\n以下是关于默认约束和默认对象的用法：\n\n默认约束的定义：默认约束是在创建表时定义的约束，用于指定列的默认值。语法如下：\n\nCREATE TABLE 表名 (    列名 数据类型 DEFAULT 默认值,    ...);\n\n\n添加默认约束：在已有表中添加默认约束，可以使用 ALTER TABLE 语句。语法如下：\n\nALTER TABLE 表名 ALTER COLUMN 列名 SET DEFAULT 默认值;\n\n\n默认对象的定义：默认对象是数据库中的一个对象，用于指定列的默认值。默认对象通常是一个函数或表达式，用于计算默认值。语法如下：\n\nCREATE FUNCTION 默认对象名 ()RETURNS 数据类型BEGIN    RETURN 默认值;END;ALTER TABLE 表名 ALTER COLUMN 列名 SET DEFAULT 默认对象名();\n\n\n默认约束和默认对象的作用：\n\n确保在插入数据时，如果未提供指定列的值，则自动使用默认值。\n提高数据的完整性和准确性，避免数据缺失或错误。\n\n\n默认约束和默认对象的区别：\n\n默认约束直接指定默认值，而默认对象可以是一个函数或表达式。\n默认约束适用于简单的默认值设定，而默认对象适用于复杂的默认值计算。\n\n\n使用场景：\n\n默认约束适用于简单的默认值设置，如固定值或常量。\n默认对象适用于复杂的默认值计算，如根据其他列的值计算默认值。\n\n\n\n总之，默认约束和默认对象是数据库中用于指定列默认值的重要概念。在设计数据库时，根据实际需求选择合适的方式来设置默认值，以提高数据的完整性和准确性。\n掌握CHECK约束和规则对象的用法（5分）CHECK 约束和规则对象是关系型数据库中用于限制列值的约束和规则。它们可以确保数据的完整性和准确性，只允许符合指定条件的数据被插入或更新。\nCHECK 约束的用法：\n定义 CHECK 约束：在创建表时，可以使用 CHECK 约束限制列的取值范围或条件。语法如下：\n\nCREATE TABLE 表名 (    列名 数据类型 CHECK (条件),    ...);\n\n\n添加 CHECK 约束：在已有表中添加 CHECK 约束，可以使用 ALTER TABLE 语句。语法如下：\n\nALTER TABLE 表名 ADD CONSTRAINT 约束名 CHECK (条件);\n\n\n使用场景：\n限制列的取值范围，如年龄不能为负数。\n确保数据符合特定条件，如性别只能为”男”或”女”。\n\n\n\n规则对象的用法\n定义规则对象：规则对象是数据库中的一个对象，用于定义数据的规则或条件。语法如下：\n\nCREATE RULE 规则名 AS @条件;\n\n\n将规则对象应用到列上：可以通过 ALTER TABLE 添加规则对象到列上，用于限制数据的取值范围或条件。语法如下：\n\nALTER TABLE 表名 ADD CONSTRAINT 约束名 CHECK (规则名(列名));\n\n\n使用场景：\n定义复杂的数据规则，如联合多个列的取值条件。\n可以被多个列引用，提高数据的一致性和准确性。\n\n\n\n总之，CHECK 约束和规则对象是数据库中重要的约束和规则定义工具，用于确保数据的完整性和准确性。在设计数据库时，根据实际需求选择合适的方式来定义数据规则，以提高数据的质量和准确性。\n掌握利用主键与外键约束实现参照完整性的方法（5分）主键约束和外键约束是关系型数据库中用于实现参照完整性（Referential Integrity）的重要工具。通过主键约束和外键约束，可以确保数据之间的关联关系正确并且保持一致性。\n利用主键与外键约束实现参照完整性的方法：\n\n主键约束：\n\n主键约束用于唯一标识表中的每条记录，确保每条记录都有唯一的标识符。\n在创建表时，通过指定主键约束可以将某列或某组列定义为主键。\n主键约束可以保证表中每条记录的唯一性，且不允许为空值。\n\n\n外键约束：\n\n外键约束用于建立表与表之间的关联关系，确保参照表中的外键值必须在被参照表的主键中存在。\n在创建表时，通过指定外键约束可以将某列定义为外键，参照另一张表的主键。\n外键约束可以确保数据之间的关联关系正确，防止出现不一致或无效的引用。\n\n\n实现参照完整性的步骤：\n\n在被参照表中定义主键约束，确保每条记录有唯一的标识符。\n在参照表中定义外键约束，将外键与被参照表的主键关联起来。\n当插入或更新数据时，数据库会自动检查外键约束，确保外键值在被参照表的主键中存在。\n\n\n示例：\n\n假设有两张表：users 和 orders，其中 orders 表中有一个 user_id 列用于表示订单所属用户。\n在 users 表中定义主键约束，将 user_id 列定义为主键。\n在 orders 表中定义外键约束，将 user_id 列定义为外键，参照 users 表的主键。\n这样可以确保每个订单都必须属于一个已存在的用户，保证数据的参照完整性。\n\n\n\n总之，利用主键约束和外键约束可以实现参照完整性，确保数据之间的关联关系正确并保持一致性。在设计数据库时，合理设置主键和外键约束是保证数据完整性的重要步骤。\n1)增加一个字段；2)删除一个字段; 3)增加一个约束; 4)修改字段的数据类型(4*5分)；增加一个字段(5分)ALTER TABLE 读者信息表ADD 身份证号 CHAR(29);\n\n删除一个字段(5分)ALTER TABLE 读者信息表DROP COLUMN 身份证号;\n\n增加一个约束(5分)ALTER TABLE 读者信息表 ADD CONSTRAINT RMP PRIMARY KEY (借书证号);\n\n修改字段的数据类型(5分)ALTER TABLE 图书明细表MODIFY 图书编号 VARCHAR(10);\n\n1）创建索引；2）重建索引(2*5分)。创建索引(5分)CREATE INDEX idx_reader_card_number ON  读者信息表(借书证号);\n\n重建索引(5分)DROP INDEX idx_reader_card_number;CREATE INDEX idx_reader_card_numberON 读者信息表(借书证号);\n\n1) 创建视图； 2）删除视图(2*5分)。创建视图(5分)CREATE VIEW reader_borrow_return_view ASSELECT r.借书证号, r.姓名, r.性别, r.出生日期, r.借书量, r.工作单位, r.电话, r.电子邮件,b.图书编号, b.借还状态, b.借书日期, b.还书日期, b.数量, b.工号FROM 读者信息表 r,借还明细表 b WHERE r.借书证号 = b.借书证号;\n\n删除视图(5分)DROP VIEW reader_borrow_return_view;\n\n实验项目二建表-- 创建学生信息表CREATE TABLE student (    sno CHAR(3),    sname VARCHAR(20),    sex CHAR(1),    birthday DATE,    class CHAR(5));-- 插入学生信息数据INSERT INTO student VALUES(&#x27;108&#x27;, &#x27;曾华&#x27;, &#x27;男&#x27;, &#x27;1977-09-01&#x27;, &#x27;95033&#x27;),(&#x27;105&#x27;, &#x27;匡明&#x27;, &#x27;男&#x27;, &#x27;1975-10-02&#x27;, &#x27;95031&#x27;),(&#x27;107&#x27;, &#x27;王丽&#x27;, &#x27;女&#x27;, &#x27;1976-01-23&#x27;, &#x27;95033&#x27;),(&#x27;101&#x27;, &#x27;李军&#x27;, &#x27;男&#x27;, &#x27;1976-02-20&#x27;, &#x27;95033&#x27;),(&#x27;109&#x27;, &#x27;王芳&#x27;, &#x27;女&#x27;, &#x27;1975-02-10&#x27;, &#x27;95031&#x27;),(&#x27;103&#x27;, &#x27;陆军&#x27;, &#x27;男&#x27;, &#x27;1974-06-03&#x27;, &#x27;95031&#x27;);-- 创建老师信息表CREATE TABLE teacher (    tno CHAR(3),    tname VARCHAR(20),    sex CHAR(1),    birthday DATE,    prof VARCHAR(10),    depart VARCHAR(20));-- 插入老师信息数据INSERT INTO teacher VALUES(&#x27;804&#x27;, &#x27;李诚&#x27;, &#x27;男&#x27;, &#x27;1958-12-02&#x27;, &#x27;副教授&#x27;, &#x27;计算机系&#x27;),(&#x27;856&#x27;, &#x27;李旭&#x27;, &#x27;男&#x27;, &#x27;1969-03-12&#x27;, &#x27;讲师&#x27;, &#x27;电子工程系&#x27;),(&#x27;825&#x27;, &#x27;王萍&#x27;, &#x27;女&#x27;, &#x27;1972-05-05&#x27;, &#x27;助教&#x27;, &#x27;计算机系&#x27;),(&#x27;831&#x27;, &#x27;刘冰&#x27;, &#x27;女&#x27;, &#x27;1977-08-14&#x27;, &#x27;助教&#x27;, &#x27;电子工程系&#x27;);-- 创建课程表CREATE TABLE course (    cno CHAR(5),    cname VARCHAR(20),    tno CHAR(3));-- 插入课程信息数据INSERT INTO course VALUES(&#x27;3-105&#x27;, &#x27;计算机导论&#x27;, &#x27;825&#x27;),(&#x27;3-245&#x27;, &#x27;操作系统&#x27;, &#x27;804&#x27;),(&#x27;6-166&#x27;, &#x27;数字电路&#x27;, &#x27;856&#x27;),(&#x27;9-888&#x27;, &#x27;高等数学&#x27;, &#x27;825&#x27;);-- 创建成绩表CREATE TABLE score (    sno CHAR(3),    cno CHAR(5),    degree INT);-- 插入成绩数据INSERT INTO score VALUES(&#x27;103&#x27;, &#x27;3-245&#x27;, 86),(&#x27;105&#x27;, &#x27;3-245&#x27;, 75),(&#x27;109&#x27;, &#x27;3-245&#x27;, 68),(&#x27;103&#x27;, &#x27;3-105&#x27;, 92),(&#x27;105&#x27;, &#x27;3-105&#x27;, 88),(&#x27;109&#x27;, &#x27;3-105&#x27;, 76),(&#x27;101&#x27;, &#x27;3-105&#x27;, 64),(&#x27;107&#x27;, &#x27;3-105&#x27;, 91),(&#x27;108&#x27;, &#x27;3-105&#x27;, 78),(&#x27;101&#x27;, &#x27;6-166&#x27;, 85),(&#x27;107&#x27;, &#x27;6-166&#x27;, 79),(&#x27;108&#x27;, &#x27;6-166&#x27;, 81);\n\n题目1. 列出student表中所有记录的sname、sex和class列。SELECT sname, sex, classFROM student;\n\n结果：\n+-------+-----+-------+| sname | sex | class |+-------+-----+-------+| 曾华  | 男  | 95033 || 匡明  | 男  | 95031 || 王丽  | 女  | 95033 || 李军  | 男  | 95033 || 王芳  | 女  | 95031 || 陆军  | 男  | 95031 |+-------+-----+-------+\n\n2. 显示教师所有的单位即不重复的depart列。SELECT DISTINCT depart FROM teacher;\n\n结果：\n+------------+| depart     |+------------+| 计算机系   || 电子工程系 |+------------+\n\n3. 显示学生表的所有记录。SELECT *FROM student;\n\n结果：\n+-----+-------+-----+------------+-------+| sno | sname | sex | birthday   | class |+-----+-------+-----+------------+-------+| 108 | 曾华  | 男  | 1977-09-01 | 95033 || 105 | 匡明  | 男  | 1975-10-02 | 95031 || 107 | 王丽  | 女  | 1976-01-23 | 95033 || 101 | 李军  | 男  | 1976-02-20 | 95033 || 109 | 王芳  | 女  | 1975-02-10 | 95031 || 103 | 陆军  | 男  | 1974-06-03 | 95031 |+-----+-------+-----+------------+-------+\n\n4. 显示score表中成绩在60到80之间的所有记录。SELECT *FROM scoreWHERE degree BETWEEN 60 AND 80;\n\n结果：\n+-----+-------+--------+| sno | cno   | degree |+-----+-------+--------+| 105 | 3-245 |     75 || 109 | 3-245 |     68 || 109 | 3-105 |     76 || 101 | 3-105 |     64 || 108 | 3-105 |     78 || 107 | 6-166 |     79 |+-----+-------+--------+\n\n5. 显示score表中成绩为85，86或88的记录。SELECT *FROM scoreWHERE degree IN (85, 86, 88);\n\n+-----+-------+--------+| sno | cno   | degree |+-----+-------+--------+| 103 | 3-245 |     86 || 105 | 3-105 |     88 || 101 | 6-166 |     85 |+-----+-------+--------+\n\n6. 显示student表中“95031”班或性别为“女”的同学记录。SELECT *FROM studentWHERE class = &#x27;95031&#x27; OR sex = &#x27;女&#x27;;\n\n+-----+-------+-----+------------+-------+| sno | sname | sex | birthday   | class |+-----+-------+-----+------------+-------+| 105 | 匡明  | 男  | 1975-10-02 | 95031 || 107 | 王丽  | 女  | 1976-01-23 | 95033 || 109 | 王芳  | 女  | 1975-02-10 | 95031 || 103 | 陆军  | 男  | 1974-06-03 | 95031 |+-----+-------+-----+------------+-------+\n\n7. 以class降序显示student表的所有记录。SELECT *FROM studentORDER BY class DESC;\n\n+-----+-------+-----+------------+-------+| sno | sname | sex | birthday   | class |+-----+-------+-----+------------+-------+| 108 | 曾华  | 男  | 1977-09-01 | 95033 || 107 | 王丽  | 女  | 1976-01-23 | 95033 || 101 | 李军  | 男  | 1976-02-20 | 95033 || 105 | 匡明  | 男  | 1975-10-02 | 95031 || 109 | 王芳  | 女  | 1975-02-10 | 95031 || 103 | 陆军  | 男  | 1974-06-03 | 95031 |+-----+-------+-----+------------+-------+\n\n8. 以cno升序、degree降序显示score表的所有记录。SELECT *FROM scoreORDER BY cno ASC, degree DESC;\n\n+-----+-------+--------+| sno | cno   | degree |+-----+-------+--------+| 103 | 3-105 |     92 || 107 | 3-105 |     91 || 105 | 3-105 |     88 || 108 | 3-105 |     78 || 109 | 3-105 |     76 || 101 | 3-105 |     64 || 103 | 3-245 |     86 || 105 | 3-245 |     75 || 109 | 3-245 |     68 || 101 | 6-166 |     85 || 108 | 6-166 |     81 || 107 | 6-166 |     79 |+-----+-------+--------+\n\n9. 显示“98031”班的学生人数。SELECT COUNT(*)FROM studentWHERE class = &#x27;98031&#x27;;\n\n+----------+| COUNT(*) |+----------+|        0 |+----------+\n\n10. 显示score表中的最高分的学生学号和课程号。SELECT sno, cnoFROM scoreWHERE degree = (SELECT MAX(degree) FROM score);\n\n+-----+-------+| sno | cno   |+-----+-------+| 103 | 3-105 |+-----+-------+\n\n11. 显示“3-105”号课程的平均分。SELECT AVG(degree)FROM scoreWHERE cno = &#x27;3-105&#x27;;\n\n+-------------+| AVG(degree) |+-------------+| 81.5000     |+-------------+\n\n12. 显示score表中至少有5名学生选修的并以3开头的课程号的平均分数。SELECT cno, AVG(degree)FROM scoreWHERE cno LIKE &#x27;3%&#x27; GROUP BY cnoHAVING COUNT(sno) &gt;= 5;\n\n+-------+-------------+| cno   | AVG(degree) |+-------+-------------+| 3-105 | 81.5000     |+-------+-------------+\n\n13. 显示最低分大于70，最高分小于90 的sno列。SELECT snoFROM scoreGROUP BY snoHAVING MIN(degree) &gt; 70 AND MAX(degree) &lt; 90;\n\n+-----+| sno |+-----+| 105 || 108 |+-----+\n\n14. 显示所有学生的 sname、 cno和degree列。SELECT student.sname, score.cno, score.degreeFROM studentJOIN score ON student.sno = score.sno;\n\n+-------+-------+--------+| sname | cno   | degree |+-------+-------+--------+| 陆军  | 3-245 |     86 || 匡明  | 3-245 |     75 || 王芳  | 3-245 |     68 || 陆军  | 3-105 |     92 || 匡明  | 3-105 |     88 || 王芳  | 3-105 |     76 || 李军  | 3-105 |     64 || 王丽  | 3-105 |     91 || 曾华  | 3-105 |     78 || 李军  | 6-166 |     85 || 王丽  | 6-166 |     79 || 曾华  | 6-166 |     81 |+-------+-------+--------+\n\n15. 显示所有学生的 sname、 cname和degree列。SELECT student.sname, course.cname, score.degreeFROM studentJOIN score ON student.sno = score.snoJOIN course ON score.cno = course.cno;\n\n+-------+------------+--------+| sname | cname      | degree |+-------+------------+--------+| 曾华  | 数字电路   |     81 || 曾华  | 计算机导论 |     78 || 匡明  | 计算机导论 |     88 || 匡明  | 操作系统   |     75 || 王丽  | 数字电路   |     79 || 王丽  | 计算机导论 |     91 || 李军  | 数字电路   |     85 || 李军  | 计算机导论 |     64 || 王芳  | 计算机导论 |     76 || 王芳  | 操作系统   |     68 || 陆军  | 计算机导论 |     92 || 陆军  | 操作系统   |     86 |+-------+------------+--------+\n\n16. 列出“95033”班所选课程的平均分。SELECT cno, AVG(degree)FROM scoreWHERE sno IN (SELECT sno FROM student WHERE class = &#x27;95033&#x27;)GROUP BY cno;\n\n+-------+-------------+| cno   | AVG(degree) |+-------+-------------+| 3-245 | 76.3333     || 3-105 | 81.5000     || 6-166 | 81.6667     |+-------+-------------+\n\n17. 显示选修“3-105”课程的成绩高于“109”号同学成绩的所有同学的记录。SELECT *FROM scoreWHERE cno = &#x27;3-105&#x27; AND degree &gt; (SELECT degree FROM score WHERE sno = &#x27;109&#x27; AND cno = &#x27;3-105&#x27;);\n\n+-----+-------+--------+| sno | cno   | degree |+-----+-------+--------+| 103 | 3-105 |     92 || 105 | 3-105 |     88 || 107 | 3-105 |     91 || 108 | 3-105 |     78 |+-----+-------+--------+\n\n18. 显示score中选修多门课程的同学中分数为非最高分成绩的记录。mysql&gt; SELECT *FROM scoreWHERE sno IN (    SELECT sno     FROM course     HAVING COUNT(DISTINCT cno) &gt; 1) AND sno IN (    SELECT sno     FROM score     WHERE degree &lt; (SELECT MAX(degree) FROM score));-- 注意AND只能这么连接\n\n+-----+-------+--------+| sno | cno   | degree |+-----+-------+--------+| 103 | 3-245 |     86 || 105 | 3-245 |     75 || 109 | 3-245 |     68 || 103 | 3-105 |     92 || 105 | 3-105 |     88 || 109 | 3-105 |     76 || 101 | 3-105 |     64 || 107 | 3-105 |     91 || 108 | 3-105 |     78 || 101 | 6-166 |     85 || 107 | 6-166 |     79 || 108 | 6-166 |     81 |+-----+-------+--------+\n\n19. 显示成绩高于学号为“109”、课程号为“3-105”的成绩的所有记录。SELECT *FROM scoreWHERE degree &gt; (SELECT degree FROM score WHERE sno = &#x27;109&#x27; AND cno = &#x27;3-105&#x27;);\n\n+-----+-------+--------+| sno | cno   | degree |+-----+-------+--------+| 103 | 3-245 |     86 || 103 | 3-105 |     92 || 105 | 3-105 |     88 || 107 | 3-105 |     91 || 108 | 3-105 |     78 || 101 | 6-166 |     85 || 107 | 6-166 |     79 || 108 | 6-166 |     81 |+-----+-------+--------+\n\n20. 显示出和学号为“108”的同学同年出生的所有学生的sno、sname和 birthday列。SELECT sno, sname, birthdayFROM studentWHERE birthday = (SELECT birthday FROM student WHERE sno = &#x27;108&#x27;);\n\n+-----+-------+------------+| sno | sname | birthday   |+-----+-------+------------+| 108 | 曾华  | 1977-09-01 |+-----+-------+------------+\n\n21. 显示“张旭”老师任课的学生成绩。SELECT score.degreeFROM student,score,teacher,courseWHERE student.sno = score.sno AND score.cno = course.cno AND course.tno = teacher.tno AND teacher.tname = &#x27;张旭&#x27;;\n\n22. 显示选修某课程的同学人数多于5人的老师姓名。SELECT DISTINCT teacher.tnameFROM teacher,course,scorewhere teacher.tno = course.tno AND course.cno = score.cnoGROUP BY teacher.tnameHAVING COUNT(DISTINCT score.sno) &gt; 5;-- GROUP BY子句中指定的列应该与SELECT语句中选择的列相匹配。而且不能遗漏-- IN也要有这种严格对应的规则\n\n+-------+| tname |+-------+| 王萍  |+-------+\n\n23. 显示“95033”班和“95031”班全体学生的记录。SELECT *FROM studentWHERE class IN (&#x27;95033&#x27;, &#x27;95031&#x27;);\n\n+-----+-------+-----+------------+-------+| sno | sname | sex | birthday   | class |+-----+-------+-----+------------+-------+| 108 | 曾华  | 男  | 1977-09-01 | 95033 || 105 | 匡明  | 男  | 1975-10-02 | 95031 || 107 | 王丽  | 女  | 1976-01-23 | 95033 || 101 | 李军  | 男  | 1976-02-20 | 95033 || 109 | 王芳  | 女  | 1975-02-10 | 95031 || 103 | 陆军  | 男  | 1974-06-03 | 95031 |+-----+-------+-----+------------+-------+\n\n24. 显示存在有85分以上成绩的课程cno。SELECT DISTINCT cnoFROM scoreWHERE degree &gt; 85;\n\n+-------+| cno   |+-------+| 3-245 || 3-105 |+-------+\n\n25. 显示“计算机系”老师所教课程的成绩表。SELECT *FROM scoreWHERE cno IN (SELECT cno FROM course WHERE tno IN (SELECT tno FROM teacher WHERE depart = &#x27;计算机系&#x27;));\n\n+-----+-------+--------+| sno | cno   | degree |+-----+-------+--------+| 108 | 3-105 |     78 || 105 | 3-105 |     88 || 105 | 3-245 |     75 || 107 | 3-105 |     91 || 101 | 3-105 |     64 || 109 | 3-105 |     76 || 109 | 3-245 |     68 || 103 | 3-105 |     92 || 103 | 3-245 |     86 |+-----+-------+--------+\n\n26. 显示“计算机系”和“电子工程系”不同职称的老师的tname和prof。SELECT tname, profFROM teacherWHERE depart IN (&#x27;计算机系&#x27;, &#x27;电子工程系&#x27;)GROUP BY tname, prof;\n\n+-------+--------+| tname | prof   |+-------+--------+| 李诚  | 副教授 || 李旭  | 讲师   || 王萍  | 助教   || 刘冰  | 助教   |+-------+--------+\n\n27. 显示选修编号为“3-105”课程且成绩至少高于“3-245”课程的同学的cno、sno和degree，并按degree从高到低次序排列。SELECT score.cno, score.sno, score.degreeFROM scoreWHERE cno = &#x27;3-105&#x27; AND degree &gt; (SELECT MIN(degree) FROM score WHERE cno = &#x27;3-245&#x27;)ORDER BY degree DESC; \n\n+-------+-----+--------+| cno   | sno | degree |+-------+-----+--------+| 3-105 | 103 |     92 || 3-105 | 107 |     91 || 3-105 | 105 |     88 || 3-105 | 108 |     78 || 3-105 | 109 |     76 |+-------+-----+--------+\n\n28. 显示选修编号为“3-105”课程且成绩高于“3-245”课程的同学的cno、sno和degree。SELECT score.cno, score.sno, score.degreeFROM scoreWHERE cno = &#x27;3-105&#x27; AND degree &gt; (SELECT MAX(degree) FROM score WHERE cno = &#x27;3-245&#x27;);\n\n+-------+-----+--------+| cno   | sno | degree |+-------+-----+--------+| 3-105 | 103 |     92 || 3-105 | 105 |     88 || 3-105 | 107 |     91 |+-------+-----+--------+\n\n29. 列出所有任课老师的 tname 和 depart。SELECT tname, departFROM teacherWHERE tno IN (SELECT DISTINCT tno FROM course);\n\n30. 列出所有未讲课老师的 tname 和 depart。SELECT tname, departFROM teacherWHERE tno NOT IN (SELECT DISTINCT tno FROM course);\n\n+-------+------------+| tname | depart     |+-------+------------+| 刘冰  | 电子工程系 |+-------+------------+\n\n31. 列出所有老师和同学的姓名、性别和生日。(*)SELECT tname AS name, sex, birthdayFROM teacherUNIONSELECT sname AS name, sex, birthdayFROM student;\n\n+------+-----+------------+| name | sex | birthday   |+------+-----+------------+| 李诚 | 男  | 1958-12-02 || 李旭 | 男  | 1969-03-12 || 王萍 | 女  | 1972-05-05 || 刘冰 | 女  | 1977-08-14 || 曾华 | 男  | 1977-09-01 || 匡明 | 男  | 1975-10-02 || 王丽 | 女  | 1976-01-23 || 李军 | 男  | 1976-02-20 || 王芳 | 女  | 1975-02-10 || 陆军 | 男  | 1974-06-03 |+------+-----+------------+\n\n32. 检索所学课程包含学生“103”所学课程的学生学号。SELECT DISTINCT snoFROM scoreWHERE cno IN (SELECT cno FROM score WHERE sno = &#x27;103&#x27;);\n\n+-----+| sno |+-----+| 103 || 105 || 109 || 101 || 107 || 108 |+-----+\n\n33. 检索选修所有课程的学生姓名。(*)SELECT snameFROM studentWHERE NOT EXISTS (    SELECT cno    FROM course    WHERE NOT EXISTS (        SELECT *        FROM score        WHERE student.sno = score.sno AND course.cno = score.cno    ));\n\nEmpty set\n\n实验项目三1.创建一个查询图书库存量的存储过程“cx_tskcl_proc”（如果是SQL server数据库的话起这个名字，是其它数据库则按数据库的要求起名字，下面同），输出的内容包含类别号、图书编号、图书名称、库存数等数据内容。存储过程示例（MySQL）：\nDELIMITER //CREATE PROCEDURE cx_tskcl_proc()BEGIN    SELECT 类别号, 图书编号, 图书名称, 库存数    FROM 图书明细表;END //DELIMITER ;\n\n2.创建一个名为TS_CX_PROC的存储过程，它带有一个输入参数，用于接受图书编号，显示该图书的名称、作者、出版和复本数。CREATE PROCEDURE TS_CX_PROC (IN book_id INT)BEGIN    SELECT 图书名称, 作者, 出版社, 复本数    FROM 图书明细表    WHERE 图书编号 = book_id;END ;\n\n3.修改存储修改TS_CX_PROC存储过程，使之能按图书名称查询图书的相关信息。DROP PROCEDURE IF EXISTS TS_CX_PROC ;CREATE PROCEDURE TS_CX_PROC (IN book_name VARCHAR(255))BEGIN    SELECT 图书名称, 作者, 出版社, 复本数    FROM 图书明细表    WHERE 图书名称 = book_name;END ;\n\n-- 查询“航海英语”图书的信息CALL TS_CX_PROC(&#x27;航海英语&#x27;);-- 查询“艺海潮音”图书的信息CALL TS_CX_PROC(&#x27;艺海潮音&#x27;);+----------+--------+--------------------+--------+| 图书名称 | 作者   | 出版社             | 复本数 |+----------+--------+--------------------+--------+| 航海英语 | 陈宏权 | 武汉工业大学出版社 |     25 |+----------+--------+--------------------+--------+1 row in set (0.05 sec)Query OK, 0 rows affected (0.00 sec)+----------+------+----------------+--------+| 图书名称 | 作者 | 出版社         | 复本数 |+----------+------+----------------+--------+| 艺海潮音 | 李叔 | 江苏文艺出版社 |     20 |+----------+------+----------------+--------+1 row in set (0.04 sec)Query OK, 0 rows affected (0.00 sec)\n\n4.删除存储过程DROP PROCEDURE IF EXISTS TS_CX_PROC;\n\n5.图书类别表上创建一个名为tslb_insert_trigger的触发器，当执行INSERT操作时，该触发器被触发，禁止插入记录。CREATE TRIGGER tslb_insert_triggerBEFORE INSERT ON 图书类别表FOR EACH ROWBEGIN    SIGNAL SQLSTATE &#x27;45000&#x27;    SET MESSAGE_TEXT = &#x27;插入记录被禁止&#x27;;END;\n\n6.在图书明细表上创建一个名为ts_delete_trigger的触发器，当执行DELETE操作时，该触发器被触发，禁止删除记录。CREATE TRIGGER ts_delete_triggerBEFORE DELETE ON 图书明细表FOR EACH ROWBEGIN    SIGNAL SQLSTATE &#x27;45000&#x27;    SET MESSAGE_TEXT = &#x27;删除记录被禁止&#x27;;END ;\n\n7.在读者信息表上创建一个名为dzxx_insert_trigger的触发器，当在读者信息表中插入记录时，将该记录中的借书证号自动插入借还明细表中。CREATE TRIGGER dzxx_insert_triggerAFTER INSERT ON 读者信息表FOR EACH ROWBEGIN    INSERT INTO 借还明细表 (借书证号)    VALUES (NEW.借书证号);END ;\n\n8.删除触发器DROP TRIGGER IF EXISTS dzxx_insert_trigger;\n\n实验项目四数据库设计报告：教材管理系统系统需求分析报告项目名称：教材管理系统\n项目背景： 教材管理系统旨在帮助学校或教育机构管理教材的信息，包括教材的库存、借阅、归还等操作，以提高教材管理的效率和准确性。\n功能需求：\n\n教材信息维护：包括教材信息的添加、修改、删除等操作。\n学生信息维护：包括学生信息的添加、修改、删除等操作。\n借阅管理：记录学生借阅教材的信息，包括借阅日期、归还日期等。\n教材库存管理：跟踪教材的库存数量，及时更新库存信息。\n\n非功能需求：\n\n界面简洁清晰，易于操作。\n数据安全性和保密性。\n高效的数据查询和管理功能。\n\n2. 概念模型的设计（E-R图）在概念模型设计中，我们定义以下实体和它们之间的关系：\n\n实体：教材、学生、借阅记录、教材库存\n\n属性：每个实体的属性，如教材的编号、名称等，学生的学号、姓名等\n\n\n\n\n在这个E-R图中：\n\n学生（Student）和教材（Textbook）之间是多对多的关系，用关联实体借阅记录（BorrowRecord）表示。\n教材（Textbook）和教材库存（Inventory）是一对多的关系，即一个教材可以有多本库存。\n借阅记录（BorrowRecord）包含了学生借阅教材的信息，如借阅日期、归还日期等。\n\n3. 关系数据模型的设计\n学生表（学生学号,姓名,性别）\n教材表（编号,教材名,作者，出版日期，出版社）\n借阅记录表（借阅日期,归还日期，学生学号，教材编号）\n教材库存表（教材编号，数量，位置）\n\n图书馆日常事务管理系统数据库设计（1）图书馆日常事务管理系统功能简析\n图书信息维护：主要完成图书信息登记、修改、删除等操作。\n读者信息维护：主要完成读者信息的添加、修改和删除等操作。\n工作人员信息维护：主要完成工作人员信息的添加、修改和删除等操作。\n图书类别的管理：主要完成图书类别的添加、修改和删除等操作\n图书借还管理：主要完成读者图书借还信息的记录。\n\n（2）图书馆日常事务管理系统中的实体和属性的设计\n读者（借书证号，姓名，性别，出生日期，借书量，单位，电话，E-mail）\n\n图书（图书编号，图书名称，作者，出版社，定价，购进日期，购入数，复本数，库存数）\n\n工作人员（工号，姓名，性别，出生日期，联系电话，E-mail）\n\n图书类别（类别号，图书类别）\n\n\n其中，每本图书都有惟一的一个图书类别，每个图书类别有多本图书；每个读者可以借阅多本图书；工作人员负责读者的借、还工作。\n（3）设计该系统数据库的E-R图\n（4）将设计好的E-R图转换为关系模式\n读者（借书证号，姓名，性别，出生日期，借书量，单位，电话，E-mail）\n图书（图书编号，图书名称，作者，出版社，定价，购进日期，购入数，复本数，库存数）\n工作人员（工号，姓名，性别，出生日期，联系电话，E-mail）\n图书类别（类别号，图书类别）\n图书借阅（图书编号，借书证号，借出日期，归还日期）\n图书借还（图书编号，工号，借还，数量，借书日期，还书日期）\n\n（5)对设计好的关系模式进行规范化的处理上述的关系模式已经符合第三范式，在这里不需要进行规范化处理。\n","categories":["数据库"],"tags":["实验"]},{"title":"操作系统与安全笔记","url":"/2025/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/","content":"第一章（导论）4个A\n • 认证 (Authentication) - 示例：用户输入密码进入windows界面 • 访问控制&#x2F;授权 (Authorization) - 示例：获取administer权限后打开文件 • 审计 (Auditing) - 示例：审计日志记录操作 • 响应 (Response) - 示例：文件成功打开\n操作系统目标&#x2F;定义\n控制管理计算机软硬件资源、合理组织计算机工作流程、以方便用户使用的计算机 的程序的集合\n功能\n\n存储管理： 就像整理你的书包，把东西放好，需要的时候容易找到。\n • 内存分配： 就像在停车场里分配停车位，确保每辆车都有地方停。 • 内存保护： 就像给重要的文件加密，防止被他人篡改。 • 地址映射： 就像给每个房间分配一个门牌号，方便找到对应的房间。 • 内存扩充： 就像扩建停车场，增加更多的停车位。\n\n处理机管理\n进程控制： 就像交通信号灯，控制车辆的行驶，避免交通堵塞。\n进程同步： 就像多人合作完成一个项目，需要协调每个人的工作进度，确保最终能够按时完成。进程通信： 就像两个人打电话，互相交流信息。进程调度： 就像老师安排课程表，合理安排不同课程的上课时间。\n\n设备管理\n • 缓冲管理： 就像在餐厅里设置一个备餐区，提前准备一些菜，减少顾客的等待时间。 • 设备分配： 就像给每个工人分配工具，确保每个人都有工具可用。 • 设备处理： 就像修理损坏的电器，确保它们能够正常工作。 • 设备独立性和虚拟设备： 就像使用虚拟机，可以在一台电脑上模拟出多台电脑。\n\n文件管理\n • 外存管理： 就像管理图书馆的书架，把书按照类别摆放好。 • 目录管理： 就像图书馆的目录，方便查找需要的书籍。 • 文件操作： 就像在图书馆借书、还书。\n\n用户接口\n • 命令行接口： 就像使用命令来控制电脑，例如使用 “dir” 命令查看当前目录下的文件。 • 程序接口： 就像使用 API 来调用其他程序的功能。 • 图形接口： 就像使用鼠标和键盘来操作电脑，例如点击图标打开程序。\n\n\n操作系统类型单道批处理系统定义\n内存中只有一道作业，顺序执行\n缺点\n\n资源浪费，CPU的利用率只有7%\n用户无法控制程序开始和结束\n\n多道批处理系统（注意不是多处理机）?????????作业调度\n\n\n单个作业的执行由作业提交，作业调度，作业执行和作业完成组成\n\n出现的前提：通道技术，中断技术\n定义宏观上看起来同一时间可以运行多个程序（但实际某一时刻CPU的只有一个进程）\n优缺点优点：提高CPU的利用率，从7%到100%（理想上），内存和I&#x2F;O的利用率也提高了，增加系统的 吞吐量\n缺点：平均周转时间长了，也没有交互能力（针对多道批无交无能力提出了分时系统）\n特点 多道批的特点：&#x3D;&#x3D;多道性，无序性，调度性&#x3D;&#x3D;\n分时系统（有交互能力）定义时间片，用户数\n特点分时系统的特点：&#x3D;&#x3D;多路性，独立性，及时性，交互性&#x3D;&#x3D;（交互性可以想到是针对多道批系统没有交互 性提出来的分时系统，所以分时系统具有交互性）\n现在采用的多数为多道分时系统\n实时系统（也有交互能力）定义每个任务都有个截止时间，感觉虽然分时和实时都有及时性，但实时比分时更在意每个任务的截止 时间（开始截止、完成截止），感觉实时对时间的要求高\n特点实时系统特点：&#x3D;&#x3D;多路性，及时性，独立性，交互性，可靠性&#x3D;&#x3D;（比分时多个可靠性） \n优点实时系统比分时系统的中断能力更强\n多处理机系统定义比如安两个CPU，增加系统的吞吐量\n\n网络os\n分布式os\netc\n\n操作系统特征&#x3D;&#x3D;并发，共享，异步，虚拟，随机&#x3D;&#x3D;\n最重要的是并发、共享、虚拟\n\n\n并发是交替执行，并行是真正的同时进行\n\n操作系统评估指标方便性、有效性、可扩充性、开放性\n操作系统安全的安全目标&#x3D;&#x3D;保密性，完整性，可用性&#x3D;&#x3D;\n操作系统安全面临的威胁&#x3D;&#x3D;保密性威胁！完整性威胁！可用性威胁！&#x3D;&#x3D;\n多道程序技术定义允许多道程序装入内存并发执行，共享系统资源\n好处提高CPU利用率，设备利用率，提高系统吞吐量\n问题处理机的分配与回收，存储保护机制的实现，合理的I&#x2F;O设备分配机制，文件管理 等等\n虚拟机定义裸机在每增加一层软件后就成为一个功能更强的机器，通常将这个新的功能更强的机器称为虚拟机\n第二章（OS基本概念）硬件保护&#x3D;&#x3D;内核态和用户态&#x3D;&#x3D;\n内核模式下，执行代码可以完全且不受限制的访问底层硬件\n用户模式下，执行代码不能直接访问硬件或引用内存，必须委托系统API（应用程序接口）【系 统调用】\n&#x3D;&#x3D;特权指令和非特权指令&#x3D;&#x3D;\n特权指令只能在内核态才允许执行，只有操作系统才能执行的指令\n非特权指令是在用户态执行的指令，用户可以执行的指令\n安全内核包括：引用验证机制，访问控制机制，授权机制，授权管理机制\n引用监视器在用户和系统资源之间实施一种授权访问关系\n可信计算基（TCB）计算机系统内保护装置的总体，包括硬件、固体、软件和负责执行安全策略的组合体\n第三章（进程与线程）临界区&#x2F;临界资源\n单道程序执行执行流程输入-运行-输出\n特点顺序性，封闭性，可再现性\n多道程序执行执行流程执行-停止-执行\n特点不封闭，不可再现\n前驱图（要会画）\n进程定义：&#x3D;&#x3D;一个&#x3D;&#x3D;具有&#x3D;&#x3D;一定独立功能&#x3D;&#x3D;的可并发执行的程序，在&#x3D;&#x3D;一个数据集合&#x3D;&#x3D;上的&#x3D;&#x3D;一次运行过程&#x3D;&#x3D;\n特性：并发性，可并发执行\n动态性，有生命周期（从进入内存始才被称为进程，直到完成出了内存）\n 制约性，对资源的争用，直接制约，间接制约\n独立性，进程作为一个独立单位运行，独立体现在拥有一定独立的资源和可被独立调度\n结构特征\n异步性，走走停停，不可预知\n进程与程序是多对多的关系\n并发性，动态性，独立性\n进程&#x3D;程序+数据+PCB\n进程与程序的区别和联系PCB（进程控制块）定义是进程存在的唯一标识（因为PCB有PID）\n\n组织方式线性方式，链接方式，索引方式\n\n进程的状态三级调度\n离cpu越近，调度等级越低\n\n低级调度（内存-&gt;CPU）：进程调度（就绪-&gt;执行）\n中级调度(内存-&gt;外存)：内存调度，在内存使用情况紧张时，将一些暂时不能运行的进程从内存中对换到外存中等待。（挂起&#x2F;解挂:活动就绪&lt;–&gt;静止就绪，活动阻塞&lt;–&gt;静止阻塞）\n高级调度（外存-内存）：作业调度，分配资源，建立PCB（后备队列-新建）\n状态转换三态模型运行态（内存）\n就绪态（活动就绪在内存，静止就绪在外存）：差CPU，其他资源都有了\n阻塞态（活动阻塞在内存，静止阻塞在外存）\n五态模型加上：\n新建态（内存）\n终止态（内存）：进程结束、未从队列撤销、要回收资源\n\n\n操作系统的内核定义与硬件紧密相关、运行频率较高的软件\n功能中断处理、时钟管理、原语操作，和各种管理功能\n\n\n中断处理（Interrupt Handling）：中断是操作系统内核和硬件之间的一种通信机制，用于处理硬件设备发出的异步事件。当硬件设备需要处理的事件发生时，会产生中断信号，操作系统内核会相应地中断当前正在执行的程序，进行中断处理程序的执行。中断处理包括中断优先级管理、中断向量表、中断服务程序等。\n时钟管理（Clock Management）：时钟管理是操作系统内核的一项重要功能，在操作系统中有一个系统定时器（系统时钟）用于跟踪时间，对系统的时间和进程执行时间进行管理。时钟管理涉及系统时钟的初始化、时钟中断处理、时间片轮转调度等。\n原语操作（Primitive Operations）：原语是操作系统内核提供的基本原子操作，具有不可分割性和排他性。原语操作在多进程并发执行的环境中，用于确保共享资源的原子性操作，避免多个进程对同一个资源造成竞争问题。\n管理功能（Management Functions）：操作系统内核还包括各种管理功能，如进程管理、存储器管理、文件系统管理、I&#x2F;O 设备管理等。进程管理包括进程的创建、撤销、调度等；存储器管理负责为进程分配、回收内存资源；文件系统管理负责文件的存储、访问等；I&#x2F;O 设备管理负责管理系统中的各种输入输出设备。\n\n\n进程创建前驱图描述前后关系，而进程图描述父子关系\n\n创建时的工作1、申请一段空白内存空间用来存储PCB\n2、初始化PCB\n3、为新进程分配资源\n4、将新进程插入就绪队列\n\nPARENT: value=5\n\n\n父子进程属于不同的进程空间，父进程的变量会在子进程中复制一份，属于不同的变量了。\n注意print的没有&#x2F;n的话资源也会复制一份\n\n\n\n\n以下全都包含主进程：\n没有循环的话，$$2^{k}$$\nfor循环子进程也会进入，如果是k+1次循环,$$2^{k}+ 2^{k-1} + …… + 2^{0}$$\n\n线程进程间切换开销大，提出线程。线程是进程的一部分，线程共享所属进程的资源\n线程与线程之间可并发；同一进程中的线程切换不会引起进程切换。\n\n&#x3D;&#x3D;资源分配的基本单位是进程，调度的基本单位是线程&#x3D;&#x3D;\n\n这是关于用户线程和内核线程之间控制块的一个简要比较：\n\n用户线程（User Level Thread）：在用户空间管理线程的API和调度，不需要通过系统调用来创建、切换线程。用户线程是由用户程序直接管理的，因此不具备系统级的控制块（TCB）。用户线程通过用户态的线程库来管理，因此内核并不知道用户线程的存在。\n\n内核线程（Kernel Level Thread）：内核线程是由操作系统内核来管理并调度的，需要通过系统调用来创建、切换线程。每个内核线程都具有对应的控制块（TCB），用于存储线程的状态信息、上下文等内容。\n\n\n用户级以进程为单位，意味着用户线程在用户空间是以进程为单位管理的，只有进程概念，没有线程的概念。而内核级以线程为单位，意味着内核线程是由操作系统内核所管理的，可以直接操作线程，因此需要线程级的控制块来维护线程状态信息。\n\n第四章（进程调度）Scheduler：制定调度策略\nDispatcher：分配处理机资源\n进程调度是低级调度，按算法选择进程分配CPU资源，运行，算法要简单、快\n衡量调度算法好坏用户角度\n&#x3D;&#x3D;响应时间&#x3D;&#x3D;（区分作业响应时间和进程响应时间）\n\n作业响应时间：作业从提交开始，到第一次运行的时间（经历了提交、后备、就绪到第一次运行 前）\n进程响应时间：因为进程是在内存中才可以被叫做进程，所以进程的响应时间是从进入内存开始到 第一次运行之前（经历了就绪到第一次运行前）\n\n&#x3D;&#x3D;周转时间&#x3D;&#x3D;\n\n作业从提交到作业完成的时间（所有等待+运行时间） \n所以：等待时间 &#x3D; 周转时间 - 运行时间\n平均周转时间\n加权平均周转时间：看的是不要等太久\n\n\n&#x3D;&#x3D;截止时间保证&#x3D;&#x3D;\n\n&#x3D;&#x3D;优先权准则&#x3D;&#x3D;\n\n\n系统角度\n&#x3D;&#x3D;系统吞吐量&#x3D;&#x3D;（吞吐量是单位时间内系统所能处理的任务数）\n\n&#x3D;&#x3D;CPU利用率&#x3D;&#x3D;\n\n&#x3D;&#x3D;各类资源的平均利用&#x3D;&#x3D;\n\n\n&#x3D;&#x3D;调度算法&#x3D;&#x3D;等待时间 &#x3D; 完成时间 - 到达时间(提交时间) - 执行时间\n甘特图\n\n 考虑到等待时间的都是饱\n\nFCFS先来先服务%饱优点：简单\n缺点：平均等待时间长，短作业不利，紧迫型作业不利\nSJF短作业优先（抢占式&#x2F;非抢占式）%饿执行时间短的先分配给它CPU，默认是非抢占式\n优点：平均等待时间最短，系统吞吐量增加\n缺点：长作业不利，且需要知道每个作业所需的执行时间\n时间片轮转RR%饱Round-Robin scheduling\n设置时间片，就绪队列中的进程轮流分配时间片\n优点：平均响应时间短（进程响应时间是进内存到第一次执行前）\n缺点：性能依赖时间片，时间片不是越长越好\n优先权调度（抢占式、非抢占式）%饿优先权越高的，越先分配给它CPU\n高响应比优先HRRN(动态优先权)%饱响应比Rp &#x3D; 周转时间&#x2F;运行时间\n\n带权周转时间也是这个\n\n多级队列调度%饿\n高优先权队列为空时，才调度低一级优先权队列中的进程\n多级反馈队列%饿\n每次新来的进程先进入到高优先权的队列\n那么Q1中的作业在经历了时间片为N的时间后，若还没有完成，则进入Q2队列等待\n\n可能会导致饥饿，如果有大量短时间进程进入，则那些退为低级进程的队列可能会饿死。\n\n实时系统调度必须要满足对截止时间的要求，&#x3D;&#x3D;抢占式调度&#x3D;&#x3D;，中断能力要强\n\n箭头表示最晚开始时间\n挑选区域内更紧迫的任务-运行（边运行边把开始时间完后延）-到达一方最晚开始时间切换\n如果紧迫程度相同，则看谁截止时间（进入时间+执行时间）更早\n划区域-挑任务-移时间-适时切换\n\n\n第五章（进程同步和通信）进程关系\n间接制约：&#x3D;&#x3D;互斥&#x3D;&#x3D;\n\n直接制约：&#x3D;&#x3D;同步(某种时序上的关系)  &#x3D;&#x3D;&#x3D;\n进程的关系是互斥和同步！！！\n\n\n同步遵循的四大原则\n&#x3D;&#x3D;空闲让进&#x3D;&#x3D;\n&#x3D;&#x3D;忙则等待&#x3D;&#x3D;\n&#x3D;&#x3D;有限等待&#x3D;&#x3D;\n&#x3D;&#x3D;让权等待&#x3D;&#x3D;\n\n互斥的实现软件方法解决互斥\n简单的&#x3D;&#x3D;flag[i]&#x3D;&#x3D;表达自己意愿\n\n&#x3D;&#x3D;违反忙则等待&#x3D;&#x3D;（同时进入）\n\n仅用&#x3D;&#x3D;turn&#x3D;&#x3D;表明哪个进程能进入临界区\n\n&#x3D;&#x3D;不满足空闲让进&#x3D;&#x3D;\n\n&#x3D;&#x3D;Peterson算法&#x3D;&#x3D;，flag[i]+turn\n\n&#x3D;&#x3D;不满足让权等待&#x3D;&#x3D;，让权等待要求若自己不能进入临界区，必须释放CPU\n\n\n硬件方法解决互斥（快）\n\n&#x3D;&#x3D;TS指令&#x3D;&#x3D;（TS是原语，不允许被中断）：若临界区空闲，跳出循环并将临界区上锁，执行相应操作后解锁；若不是，重复上锁的操作。&#x3D;&#x3D;不满足让权等待&#x3D;&#x3D;\n\n&#x3D;&#x3D;swap指令&#x3D;&#x3D;：若临界区空闲，则lock为false，跳出循环并将临界区上锁，执行相应操作后解锁；若不是，按兵不动。&#x3D;&#x3D;不满足让权等待&#x3D;&#x3D;\n\n\n同步的解决方法信号量机制\n整型信号量\n\n\n记录型信号量\n\n\nAND信号量集机制\n\n\n一般信号量集机制\n\n\n\n进程同步问题&#x3D;&#x3D;生产者-消费者问题&#x3D;&#x3D;\n\n重点：1. 判断blocking queue里面还有多少个空位置待producer填充，还有多少份物资待consumer消费 2. 判断blocking queue是否已经被一方占用\n\nsemaphor-信号量（整形信号量mutex，记录型信号量empty和full）\n其它：buffer；位置in和out\n\n\nwait不能颠倒：先拿到了临界区权限却因为empty或full无法访问临界区，使本进程阻塞，而另一个进程又因为没有访问权限而阻塞\n\n不要忘记mod n\n\n&#x3D;&#x3D;读者-写者问题&#x3D;&#x3D;\n写者和读者&#x2F;写者互斥\n\n读者优先：假设读者写者进来顺序为rrwrr,那么执行顺序为rrrrw\n互斥读者（rmutex）；互斥写者和其它（wmutex）；表示读者数量，需看成临界资源，即进来一个读者就+1操作（readcount）\n\n注意if(readcount&#x3D;&#x3D;0)后是wait(mutex),而不是mutex&#x3D;0;\n\n\n\n\n\n写者优先：当有读者进程正在执行，写者进程发出申请，这时应该拒绝其他读者进程的请求，等待当前读者进程结束后立即执行写者进程，只有在无写者进程执行的情况下才能够允许读者进程再次运行。\n其实相较于读者优先，设置了一个readable整形信号量，当有写者数量为0或不为0时修改。\n互斥读者与写者（mutex）；互斥读者（rmutex ）；互斥写者（wmutex）；表示是否还有写者（readable）；读者数量，写者数量（readcount, writecount ）\n// 互斥读者与写者semaphore mutex = 1;// 互斥读者semaphore rmutex = 1;// 互斥写者semaphore wmutex = 1;// 表示是否还有写者semaphore readable = 1; // 读者数量，写者数量int readcount = 0, writecount = 0; void reader()&#123;\t// 先看是否可读\tP(readable);\t// 互斥其他读者修改readcount\tP(rmutex);\tif(readcount == 0)\t\t// 如果没有读者，需要互斥写者\t\tP(mutex);\treadcount++;\tV(rmutex);\tV(readable);\t/* 读取中 */\tP(rmutex);    readcount--;\tif(readcount == 0)\t\tV(mutex);\tV(rmutex);&#125; void writer()&#123;\t// 互斥其他写者，写入writecount\tP(wmutex);\tif(writecount == 0)\t\t// 此时不能让写者以后的读者进去\t\tP(readable)\twritecount++;\tV(wmutex);\t// 互斥在写者之前的读者\tP(mutex);\t/* 写入中 */\t// 写入完成离开\tV(mutex);\tP(wmutex);\twritecount--;\tif(writecount == 0)\t\t// 让写者以后的读者可读\t\tV(readable);\tV(wmutex); &#125; void main()&#123;\treader();\twriter();\treader();\t/* ... */&#125;\n\n&#x3D;&#x3D;哲学家进餐问题&#x3D;&#x3D;\n筷子不够\n\n\n管程（像秘书）管程与进程的区别\n\n目的：进程用来并发、共享；管程用来管理临界资源\n\n系统用PCB管理进程，用等待队列管理管程\n\n管程是操作系统固有成分\n\n管程被进程调用\n\n\n进程间通信进程间通信是&#x3D;&#x3D;高级通信方式&#x3D;&#x3D;\n与之对应的，同步是低级通信方式\n\n共享存储器系统：共享数据结构&#x2F;共享存储区\n\n\n消息传递系统\n\n\n\n管道通信（Unix）\n\n\n\n第六章（死锁）死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程将永远无法推进\n&#x3D;&#x3D;死锁产生的必要条件&#x3D;&#x3D;\n互斥条件\n占有并等待\n不可抢占\n环路等待\n\n不安全状态包括死锁，但不一定会死锁\n死锁产生的原因\n资源相对不足\n\n进程推进顺序不合理\n\n\n\n死锁的预防破坏死锁的必要条件\n死锁的避免所有进程对资源的总需求量 &lt; m + n （进程数+资源数）\n银行家算法\n\n死锁的检测资源分配图化简\n第七章（实存管理）逻辑地址、物理地址\n&#x3D;&#x3D;MMU&#x3D;&#x3D;：实现重定位的硬件设备\n\n重定位方式：\n静态重定位：入内存前就完成重定位，进内存后可立即执行，且进内存后的位置就一直不变，适用 于常驻内存的进程，例如管程\n\n动态重定位：执行时重定位\n\n\n加载方式（装入方式）：\n动态加载（动态运行时装入方式）：程序在调用时加载到内存，运行时装入，对应执行时重定位\n静态加载（运行时动态链接方式）：程序在运行时已经将所有代码数据等都装到了内存\n\n分配实存：连续分配存储管理技术（逻辑地址在内存中连续）单一连续分配\n在既定范围内，通过距离重定位寄存器地址多远来确定物理地址\n固定分区分配：\n优点：分区数固定，每个进程占一个用户分区。\n缺点：可同时运行的进程数量存在上限（并发性不理想），较大内碎片\n\n\n&#x3D;&#x3D;动态分区分配&#x3D;&#x3D;：:exclamation:按需分配，不会产生外碎片\n优点：无内碎片，因为按需分配\n缺点：会有外碎片\n\n数据结构\n\n空闲分区表&#x2F;已分分区表\n\n\n空闲分区链\n\n\n\n\n基于顺序搜索的动态分区分配算法\n\n首次适应算法（First Fit）\n\n循环首次适应算法(Next Fit)\n\n最佳适应算法(Best Fit)：把大小最接近Pi需求的空闲分区给Pi，但会产生很多难以利用的很小的空闲区，也 就变成了外碎片\n\n最坏适应(Worst Fit)：每次都找最大的，并且分完后，剩余的仍最为新的空闲分区，参与下一次的比较\n\n\n\n分区分配操作\n\n分配内存\n\n回收内存\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;动态可重定位分区分配&#x3D;&#x3D;解决动态分区分配的外碎片的方法（倒不是完全解决，因为总会存在无法被合并的空闲区域或者无法移动的进程。）：&#x3D;&#x3D;紧凑&#x3D;&#x3D;\n但是紧凑的前提是采用动态重定位\n离散分配存储管理技术（也可以在虚存中应用）分段和分页的三个主要区别\n\nP-page number;S-segmentnumber;L-limit;B-base\n\n逻辑地址在内存中可不连续\n&#x3D;&#x3D;分页&#x3D;&#x3D;（有快表&#x2F;无快表）：\n因为分页存储系统的页的大小是固定的，而逻辑地址A是一个二进制的数，A对页大小取余就是你的页内偏移量，这个机制导致页内偏移永远不会越界，而页号有可能越界；分段系统段的大小不固定，因此段式系统的逻辑地址先转化成二维的（B，D），B和D都可能越界。\n\n\n页面大小是2的整数幂\n\n逻辑地址转换为物理地址：框号 * 页框大小 + 页内偏移(d) \n访问内存：2次（查找页表+实际访问物理地址）\n\n&#x3D;&#x3D;有效访问时间的计算&#x3D;&#x3D;\n\n有快表：\n\n\n\n\n\n&#x3D;&#x3D;分段&#x3D;&#x3D;\n\n主存地址内存是动态分区分配\n\n&#x3D;&#x3D;段页式&#x3D;&#x3D;\n仅针对虚存\n\n\n\n\n支持动态内存分配-外碎片【紧凑-少；其它-多】  不支持动态内存分配-内碎片【内存大小完全固定-最多；内存大小有限制+段碎片+页碎片-多；内存大小有限制+页碎片-少】（外碎片是指内存中分散的一些小块未被使用的空间）\nbitmap\n\n\n第八章（虚存管理）\n虚拟内存（虚存）：虚拟内存是一种技术，通过将部分数据保存在磁盘上以扩展物理内存的容量，从而提高系统的性能和效率。程序在执行时候不需要完全加载到内存中，而是根据需要加载虚拟地址空间中的页面。虚拟内存是一种逻辑上的空间，允许程序使用比真实物理内存更大的内存空间。\n\n局部性原理\n硬件支持\n页表结构 &#x2F; 段表结构\n中断机制\n地址变换机构\n\n虚存的特征：\n\n实现方式：请求分页&#x2F;请求分段&#x2F;请求段页式\n\n请求分页\n动态运行时加载，页面只在需要时加载入内存，且只有部分加载进内存\n页表（PMT）：保存作业各页进入内存的情况\n\n\n产生缺页中断的处理过程\n若算得的逻辑页号超出页表长度，则越界中断\n\n页表\n\n\n&#x3D;&#x3D;页面置换算法！！&#x3D;&#x3D;\n目标：缺页次数低 &#x2F; 缺页率低\n\n先进先出FIFO：注意当所需页面在页框时，不用变顺序，因为看的是谁最先进来而不是最近使 用；belady现象\n\n最佳置换算法OPT（Optimal Replacement Policy）：理论的，实际不行；以后一段很长时间不用的页面先置换\n\n最近最久未使用LRU（Least Recently Used）：最近很长时间不用的页面先置换\n\n\n\n\n\nclock置换算法\n\n当内存中无对应数据时访问位为0即可置换之后再变换访问位，访问位为1不置换仍然变换访问位然后指针下移。当内存中有对应数据时，访问位变换，指针下移。\n\n最少使用算法：根据近期使用次数（之前）\n\n最多使用算法\n\n\n\n\n注意：内存访问时间可忽略\n\n\n页面缓冲算法\n\n抖动\n\n预防抖动是指由于频繁的页面置换导致系统性能下降的情况。以下是几种预防抖动的方法：\n\n局部置换（Local Replacement）： 局部置换是一种页面置换算法，在发生缺页时只在一部分页面中进行页面的置换操作。这样可以减少全局置换算法中可能导致抖动的频繁置换操作，提高页面置换的效率和系统性能。\n\n工作集算法（Working Set Algorithm）： 工作集是指程序在一段时间内访问的页面集合。工作集算法根据程序的工作集大小来动态调整内存分配，保证工作集所需的页面能够常驻内存，从而减少页面置换的频率，避免发生抖动。\n\n调整道数： 在虚拟存储管理中，将物理内存划分为若干个固定大小的区域称为”道”。通过适当调整道的数量和大小，可以优化内存的分配和页面置换策略，减少抖动的发生。\n\n挂起若干进程： 当系统内存不足且出现抖动时，可以选择将一些耗费内存较多、且不太紧急的进程挂起，释放部分内存资源供其他进程使用。这样可以减轻内存压力，降低抖动的发生。\n\n\n通过采取上述预防抖动的方法，可以有效地减少页面置换过程中可能引起的性能下降和抖动现象，提高系统的运行效率和稳定性。每种方法都有其特定的应用场景和优缺点，根据系统的实际情况选择合适的方法来预防抖动。\n\n第九章（文件系统接口）概念\n文件模型层次结构\n索引节点磁盘索引节点\n内存索引节点\n文件逻辑结构\n&#x3D;&#x3D;顺序文件&#x3D;&#x3D;\n\n适合对记录批量存取\n缺点：增删不便；查找单条记录慢\n\n&#x3D;&#x3D;索引文件&#x3D;&#x3D;\n\n查找快，增删方便\n缺点：要额外开销存索引表每次先访问索引表，再找记录\n适合对信息处理及时性要求高的场合\n\n&#x3D;&#x3D;索引顺序文件&#x3D;&#x3D;\n\n顺序文件记录分组\n访问方法\n&#x3D;&#x3D;顺序访问&#x3D;&#x3D;\n\n适用于顺序文件，例如磁带\n不但适用于顺序访问设备，也适用于随机访问设备\n\n&#x3D;&#x3D;直接访问&#x3D;&#x3D;\n\n适用于索引文件、索引顺序文件\n&#x3D;&#x3D;磁盘和U盘都支持顺序访问和直接访问&#x3D;&#x3D;\n目录：目录也存放在磁盘中\n四大要求（目的）按名存取\n目录检索速度快\n允许文件重名\n文件共享功能\n目录结构\n单级目录结构\n\n查找慢（遍历查找平均N&#x2F;2） 不支持重名和文件共享\n\n二级目录结构\n\n\n\n比单级多建了一级用户文件目录提高查找速度\n不同用户之间允许重名但仍不支持文件共享\n\n&#x3D;&#x3D;树形目录结构&#x3D;&#x3D;（最常用） \n\n也不能共享\n\n无环图目录结构\n\n\n通用目录结构\n\n\n\n文件共享\n绕弯路法\n\n先回父目录[父…]，然后再下去找\n\n连访法\n\n使目录项直接指向另一个目录项\n\n基本文件目录\n\nBFD是基本文件目录\n\n基于索引结点的共享\n\n索引结点存储文件的一堆属性\n文件目录只包括文件名和指向对应索引结点的指针\n\n利用符号链接实现共享\n\nLampson访问矩阵\n访问控制表\n\n按列划分，跟着对象跑，记录在FCB中\n\n\n权能表\n\n跟着进程跑，设置在PCB中\n存取控制机制9位二进制数，三个数字，分别为属主，属组和其他人，每三位分别代表&#x3D;&#x3D;读、写、执行&#x3D;&#x3D;\n例如若是761，则owner的7说明111，三种权限他都有；属组110，可读可写不可执行；其他人001， 不可读不可写，只可执行。\nchmod可以更改权限\n第十章（文件系统的实现）\n\n注意磁盘块号是从0开始的\n磁盘访问时间延迟时间（寻扇区）：转半圈所需要的时间（旋转延迟）+ 控制器时间\n寻道时间：Ts\n数据传输时间：Tt &#x3D; 数据所占盘块数*(60&#x2F;2)&#x2F;一圈盘块数    或者    Tt &#x3D; 数据总量&#x2F;传输率\n具体要分是顺序存储还是随机存储，随机存储比顺序存储主要多在寻道时间，但更普遍的是随机存储， 所以要最小化寻道时间\n\n顺序存储磁道是紧挨着的，所以只要计算一次寻到时间，随机存储不是\n\n\n硬盘转速单位为RPM，RPM是Revolutions per minute的缩写，是转&#x2F;每分钟。\n\n\n磁盘调度算法记得先看磁头初始在哪个磁道\n先来先服务FCFS最短寻道时间SSTF选择离自己最近的\n\n优点：寻道时间短；单位时间处理的更多，吞吐量大\n缺点：机会不均等，对离磁头远的一侧磁道不利；延迟大，可能因离得远而被严重滞后\n\n 接下来的扫描算法都是根据磁头移动方向选择下一个访问的磁道\n\n扫描算法SCAN（电梯算法）\n一般是look型的\n:exclamation:在磁头移动方向找最近\n扫描算法C-SCAN\n\n 下面两个算法是动态算法，对于源源不断的请求没有磁粘滞现象\n\nN步扫描算法N-SCAN\n\n平均寻道长度&#x3D;总长&#x2F;移动次数\n\nFSCAN扫描算法将磁盘请求队列分为2个子队列，其中一个为当前所有请求构成的队列，另一个为扫描期间新到达的请求构成的队列，并按N步扫描处理。\n文件的物理结构\n每一个磁盘有很多磁盘块号&#x2F;物理块号\n\n采用不同的分配方式时，将对应不同的文件物理结构\n\n&#x3D;&#x3D;连续分配 -&gt; 顺序文件&#x3D;&#x3D;\n\n优点\n支持顺序访问、直接访问；\n磁头定位时间短，顺序访问速度快。\n\n缺点\n要求连续盘块，易产生碎片；\n需预知文件长度\n\n\n\n\n物理块号&#x3D;起始块号+逻辑块号:\n\n&#x3D;&#x3D;链接分配 -&gt; 链接文件（串联文件）&#x3D;&#x3D;\n\n优点\n简单\n记录数可任意增减\n\n缺点\n只适用于顺序访问，不支持直接访问；\n可靠性差\n链接文件查找只能单向查找\nFAT需要磁盘空间。\n\n双向的办法：异或双向链表，即每个盘块设置一个指针值：值为前一个盘块号与后一个盘块号的异 或值；每次向前查找时就与后面的盘块号异或；向后查找时就与前一个盘块号异或；代价是计算； 但也不能支持直接访问\n\n\n隐式链接\n\n\n显示链接：设置链接表FAT\n\n显示链接是一个磁盘对应一个FAT\n\n\n\n\n\n&#x3D;&#x3D;索引分配 -&gt; 索引文件&#x3D;&#x3D;\n\n优点\n支持顺序访问和直接访问\n查找速度快；\n没有外碎片\n\n缺点\n索引表需要额外开销；\n\n单级索引\n\n\n多级索引\n\n假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。\n\n若某文件采用两层索引，则该文件的最大长度可以达到2562561KB&#x3D;65,546KB&#x3D;64MB可根据逻辑块号算出应该查找索引表中的哪个表项。如：要访问1026号逻辑块，则1026&#x2F;256&#x3D;4, 1026%256&#x3D;2因此可以先将一级索引表掉入内存，查询4号表项，将其对应的二级索引表调入内存，再查询二级索引表的2号表项即可知道1026号逻辑块存放的磁盘块号了。访问目标数据块，需要3次磁盘I&#x2F;O。\n\n\n混合索引分配\n混合索引是多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）。\n\n某系统中磁盘的每个盘块大小为1KB，外存分配方法采用中的混合索引结构，其中索引节点中直接地址6项，一级索引地址2项，二级索引地址1项，每个盘块号占用4个字节，请问该系统中允许的文件最大长度是多少?一个盘块可记录的盘块号的数量为∶1KB&#x2F;4&#x3D;256直接地址∶记录6个文件所占物理块的块号一级索引∶记录256x2&#x3D;512个文件所占物理块的块号二级索引∶记录256x256个文件所占物理块的块号该系统中允许的文件最大长度 （256x256+256x2+6）*1KB&#x3D;\n\n混合索引分配FCB：\n\nFCB  中有  i_addr[0  ]  ～  i_addr[8  ]  共  9  个物理地址项，其中  i_addr[0  ]  ～  i_addr[6  ]  是  7  个直接地址项，  i_addr[7  ]  是  1  个一次间址项，  i_addr[8  ]  是  1  个二次间址项。\n\n\n\n\n\n磁盘空闲空间管理方法空闲表法\n特点：\n\n更适合顺序文件\n\n当有大量小的空白文件时，效率降低——&gt;磁盘碎片整理\n\n\n空闲链表法\n\n位示图位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况。当其值为“0”时，表示对应的盘块空闲；为“1”时表示已分配。由所有盘块对应的位构成一个集合，称为位示图。\n&#x3D;&#x3D;成组链接法&#x3D;&#x3D;存储data_1到data_4\n存储data_5此时将data_5写入盘块1中\n\n注意：N包括盘块6的地址；存放盘块6地址的盘块也可以放东西；结束盘块放不了东西\n\n\n回收data_5（盘块1）\n回收data_4data_1\n\n题目总结\n\n解析：\n注意：1.计算空闲盘块要加上地址盘块，减去结束盘块  2.超级块块号是由盘块地址里面存储着几号盘块决定的  3.盘块是从下至上分配，从上至下回收\n（1）从图中可以看出，目前系统共有四组空闲盘块，第一组为2块，第二，三组分别为100块，第四组虽记为100快，但除去用于结束标记的那一块后实际只有99块，故空闲盘块总数为301块。 \n（2） 磁盘块的分配过程如下：首先检查超级块空闲盘块号栈是否已上锁，若已上锁则进程睡眠等待；否则将s_nfree减1，若s_nfree仍大于0，即第一组中不止一个空闲盘块，则将s_free[s_nfree]中登记的（即空闲盘块号栈顶的）空闲盘块分配出去。若s_nfree为0，即当前空闲盘块号栈中只剩下最后一个空闲盘块，由于该盘块中登记有下一组空闲盘块的盘块号和盘块数，因此核心在给超级块的空闲盘块号栈上锁后，先将该盘块的内容读入超级块的空闲盘块号栈，再将该盘块分配出去。另外，还需将空闲盘块号栈解锁，并唤醒所有等待其解锁的进程。若s_nfree为0，而且栈底登记的盘块号为0，则表示系统已无空闲盘块可分配，此时也让进程睡眠等待其他进程释放盘块。 \n（3） 根据题意，分配给某文件的3个盘块依次为299号，300号，301号这三个盘块。在此基础上依次回收另一个文件的5个盘块：700、711、703、788、701，回收完成后，空闲盘块的链接情况将如图2所示。\n\n\n文件的实现FCB：文件目录项&#x3D;&#x3D;&#x3D;文件名+索引结点号(指向索引节点，文件描述信息)&#x3D;&#x3D;——&gt;提高目录查找速度\n\n题目1、存放在某个磁盘上的文件系统，采用混合索引分配方式，其FCB中共有13个地址项，第0~9个地址项为直接地址，第10个地址项为一次间接地址，第11个地址项为二次间接地址，第12个地址项为三次间接地址。如果每个盘块的大小为512字节，若盘块号需要用3个字节来描述，而每个盘块最多存放170个盘块地址： \n（1）该文件系统允许文件的最大长度是多少？\n（2）将文件的字节偏移量5000、15000转换为物理块号和块内偏移量。\n（3）假设文件的FCB已在内存，为了访问文件中某个位置的内容，最少需要访问几次磁盘，最多需要访问几次磁盘？\n（4）对某个长度为18000000字节的文件，它需要占用多少个盘块（包括间接地址块）？\n【解答】（列出了详细的分析过程，实际回答可以简单写）\n1、(10+170+170170+170170*170）512&#x3D;4942080512字节&#x3D;2471040KB\n2、每一个盘块的大小是512字节，文件的逻辑空间每块大小也是512字节\n（1）5000&#x2F;512得到商为9，余数为392，所以字节偏移量5000对应的逻辑块号为9，块内偏移量为392。由于9&lt;10，故可直接从该文件的FCB的9号地址项处得到物理盘块号，块内偏移量为392。\n（2）15000&#x2F;512得到商为29，余数为152，即字节偏移量15000对应的逻辑块号为29，块内偏移量为152。由于10&lt;29&lt;10+170，而29-10&#x3D;19，故可从FCB的10号地址项，即一次间址项中得到一次间址的地址；并从一次间址块的19号（即该块的第57~59这3个字节）中获得对应的物理盘块号，块内偏移量为152。\n3、由于文件的FCB已在内存，为了访问文件中某个位置的内容，最少需要1次访问磁盘（即可通过直接地址直接读文件盘块），最多需要4次访问磁盘（第一次是读三次间址块，第二次是读二次间址块，第三次是读一次间址块，第四次是读文件盘块）\n4、根据题意，18000000&#x2F;512＝35156.25，因此该文件总共需要35157个盘块存储。由于10＋170＋170×170&lt;35157&lt;10＋170＋170×170＋170170170，故该文件不仅需要使用10个直接地址项，还需要使用一次、二次及三次间接地址项。又因为35157－（10＋170＋170×170）＝6077，6077&#x2F;（170×170）得到商为0，余数为6077，得知该文件在三次间接地址时还需要1个二次间接地址块；而余数6077&#x2F;170得到商为35余数为127，可知该文件在三次间接地址时还需要36个一次间接地址块。因此该文件需要：\n直接地址 10个数据盘块\n一次地址 1个一次地址块，170个数据块\n二次地址 1个二次地址块+170个一次地址块+170*170个数据块\n三次地址 1个三次地址块+1个二次地址块+36个一次地址块+（35*170+127）（或直接6077）\n\n目录的实现\n线性列表\n哈希表\n\n容错技术系统容错技术SFT三个级别：\n\n低级 (STF-1)——&gt; 防止磁盘表面缺陷引起的数据丢失\n\n写后读校验\n\n热修重复定向：磁盘设置热修复重定向区，存放发现盘块有缺陷时\n的待写数据，并登记。\n\n双目录和双FAT：在不同盘或同一盘的不同区域，建立2份目录和\nFAT。系统初启时验证一致性。\n\n\n\n中级 (STF-2)——&gt; 防止驱动器、控制器故障引起的不正常\n\n磁盘镜像 ：有两个驱动器，但由一个控制器控制\n磁盘双工 ：有两个驱动器分别连到两个磁盘控制器\n\n\n磁盘驱动器控制着磁盘驱动器读入和读出数据\n\n\n高级(STF-3) ——&gt;利用冗余的存储信息作错误校正\n\n磁盘冗余阵列RAID\n\nRAID技术通过将多个磁盘进行组合，实现数据分布和冗余存储，从而提高系统的性能和可靠性。不同的RAID级别提供不同的数据保护机制，如数据镜像、数据条带化、奇偶校验等，以保护数据免受硬件故障的影响。\n\n\n后备系统：全量转储(将整个数据集全部备份到另一个存储介质中)，增量转储(只备份变化了的数据)\n\n\n\n\n第十一章（设备管理）I&#x2F;O软件系统层次模型\n\n\n\n 硬盘也是I&#x2F;O设备\n\n设备控制器DC（可编址设备）\n\n可编址设备即可编程设备\n\n\n设备控制器是CPU与I&#x2F;O设备的接口\n功能：\n\n接收和识别CPU发出的命令\n完成数据的存储转发\n记录连接设备的状态\n识别所连接设备的地址\n\nI&#x2F;O端口（可编址设备）\n通道CPU-通道-设备控制器-I&#x2F;O设备：通过执行通道程序控制I&#x2F;O操作，提高CPU的利用率，提高整个系统的效率\nI&#x2F;O控制方式&#x3D;&#x3D;减少CPU对I&#x2F;O的干预，提高CPU的利用率&#x3D;&#x3D;\n程序I&#x2F;O控制方式（轮询）（基本不涉及）忙测试：\n\n缺点：\n\nCPU和I&#x2F;O设备串行工作；CPU长期处于循环等待\n\n每次只传输一个字(符)\n\n\n中断驱动I&#x2F;O控制方式（简单，慢）主存-CPU-设备管理器DC-I&#x2F;O设备（中断）\n\n优点：相比轮询提高了CPU的工作效率\n缺点：每次只传输一个字符；次保存现场恢复现场工作量较大\n\n例如对打印机的I&#x2F;O控制方式\nDMA控制方式（复杂，快-常用于块设备的I&#x2F;O控制）\n每次传输一个块或者几个连续块\n有数据计数器初始为传输字节数，然后不断-1-1… \n例如对硬盘的I&#x2F;O控制方式\n通道控制方式\n与DMA相比：\n\n通道所需要CPU干预更少；\n\n多个不连续块的传递和存储；\n\n\n&#x3D;&#x3D;完成I&#x2F;O后，也要中断通知CPU&#x3D;&#x3D;\n缓冲管理缓冲区是从内存开辟出来的\n缓冲引入原因\n缓和CPU与I&#x2F;O设备速度不匹配的矛盾\n\n减少CPU对I&#x2F;O的干预\n\n提高CPU与I&#x2F;O设备之间的并行程度\n\n\n无缓冲区时，每块数据的处理时间为 T(输入) + C(处理)\n\n缓冲类型专用缓存&#x3D;&#x3D;单缓冲&#x3D;&#x3D;进程发出I&#x2F;O请求时，OS分配一个缓冲区用于完成I&#x2F;O\n每块数据的处理时间为 MAX( C，T ) + M-本次的处理和下次的输入可并行（M可以忽略不计）\n&#x3D;&#x3D;双缓冲&#x3D;&#x3D;\n处理缓冲区2的数据时，I&#x2F;O设备可以将数据输入至缓冲区1\n\n每块数据的处理时间为 MAX( C，T ) + M(从缓冲区复制到内存)\n循环缓冲\n装输入数据的空缓冲区R\n已装满数据的缓冲区G\n计算进程正在使用的现行工作缓冲区C\n公用缓冲缓冲池\n三个队列\n空缓冲队列emq\n输入队列inq\n输出队列outq\n\n四个工作缓冲区\n收容输入hin\n\n收容输出hout\n\n提取输入sin\n\n提取输出sout\n\n\n设备分配中的四个表\n设备独立性（无关性）\n&#x3D;&#x3D;应用程序独立于具体适用的物理设备&#x3D;&#x3D;\n好处：\n&#x3D;&#x3D;分配灵活&#x3D;&#x3D;：某个设备坏了或被占用，可以在不修改应用程序情况下，用其它同类设备代替 \n&#x3D;&#x3D;易于I&#x2F;O重定向&#x3D;&#x3D;（逻辑设备——&gt;物理设备）\n逻辑设备表LUT：逻辑设备到物理设备的映射\nSPOOLing系统\n\nspi是输入进程，spo是输出进程\n\n思想主机的直接控制下，实现脱机输入、 输出功能。 此时的外围操作与CPU对数据的处理同时进行。 \n\n速度：独占设备&lt;高速外存&lt;缓冲区&lt;CPU\n缓冲区在内存（缓和CPU和磁盘的速度不匹配矛盾） \n\n工作过程输入过程-用来模拟脱机输入时的外围控制机：\n​\tSpi是系统中一个独立的进程，无任务时，处于等待状态（睡眠状态）。\n​\t根据唤醒实际不同，SPi的工作：\n（1）设备有输入请求；\n​\t启动通道：输入设备-输入缓冲区；自身进入等待。\n（2）输入设备出现结束中断；\n​\t建立JCB；输入井中为作业分配空间；启动磁盘通道：输入缓冲区-输入井；自身进入等待。\n（3）向输入井传输作业结束，出现磁盘结束中断；\n​\t将JCB加入后备队列；引起作业调度；自身进入等待。\n输出过程-用来模拟脱机输出时的外围控制机\n​\t内存-输出井-缓冲区-输出设备\n\n&#x3D;&#x3D;进程输入&#x2F;输出是跟磁盘上的输入&#x2F;输出井对接的&#x3D;&#x3D;\n&#x3D;&#x3D;进程从输入输出井存取数据&#x3D;&#x3D;（也是相当于内存跟输入输出井进行数据往来）\n对进程来说，输入输出井相当于是它的输入输出设备\n输出井模拟磁盘\n\n特点\n提高I&#x2F;O速度\n将独占型设备改造为共享型设备：Spooling系统通过引入缓冲、队列管理、并发处理等机制，可以将原本的独占型设备（如打印机）改造为共享设备，实现多用户同时访问和使用设备\n实现了虚拟设备功能\n\n\nspooling系统还有个守护进程-守护进程是允许使用该独占设备的唯一进程，其它所有进程都不能直接使用该设备，只能将对该设备的使用要求写入一份文件中，放在假脱机目录中。由守护进程按照目录中的文件依次来完成诸进程对该设备的请求，这样就把一台独占设备改造为可为多个进程共享的设备。\n\nSPOOLing技术实现打印机共享\n第十二章（操作系统的安全机制）安全目标（四个A）\n认证（Authentication）\n\n访问控制或授权（Access control） \n\n审计 (Auditing)\n\n响应 (Action)\n\n\n操作系统的安全目标CIA三元组机密性，完整性，可用性\n额外的特性可追究性\n概念主体主动，使信息在客体间流动或者改变系统状态\n客体被动，包含或接收信息\n隐蔽通道不用于传送信息却被利用干这事\n内核态和用户态\n内核态：核心态，执行代码可以完全且不受限制的访问底层硬件，特权指令是只有内核态才能执行 的指令\n\n用户态：执行代码不能直接访问底层硬件或引用内存，必须委托系统API，非特权指令是在用户态 执行的指令\n\n\nLampson访问矩阵保护域\n一个域是一个访问权限的集合，每一个访问权限是一个有序对&lt;对象名，权限集&gt;。\n\n\n访问控制表(按列划分，跟着对象)\n在 ACL 中，按列划分，跟着对象，意味着每一列表示了对应资源或对象的访问控制信息，而每一行则表示了具有访问权限的主体（如用户、用户组或进程）以及其被允许的操作。\n\n\n\n执行在域D1中的进程可以读取文件F1，F3,还可以切换到D2\n\n\n执行在域D2中的进程可以复制读操作到与文件F2关联的任何条目。\n权能表（按行，跟着进程）\n引用监视器\n&#x3D;&#x3D;控制用户授权访问系统资源&#x3D;&#x3D;\n以主体(用户等)所获得的引用权限为基准，验证程序在执行过程中对客体的所有引用\n引用监视器在操作系统安全内核，引用监视器在可信计算基内部\n可信计算基TCB&#x3D;&#x3D;可信计算基是计算机系统内保护装置的总体，包括硬件、固体、软件和负责执行安全策略的组合体&#x3D;&#x3D;\n 尽可能小\n操作系统安全机制&#x3D;&#x3D;硬件安全机制&#x3D;&#x3D;存储保护：保护存储器中的数据\n运行保护：分层保护环、\nI&#x2F;O保护：I&#x2F;O读写操作保护\n标识与鉴别基于口令的鉴别方法\n\n\nuid和gid都具有唯一性\n\npasswd：\n\n所有用户都能看\n\n存储用户信息\n\n密码不可见\n\n\nshadow：\n\nroot及特殊权限可以看\n存储密码信息\n密码加密后显示\n\n\n&#x3D;&#x3D;访问控制&#x3D;&#x3D;防止用户对系统资源的非法使用\n自主访问控制DAC\n资源的拥有者（主人）可以自主设置谁可以访问，谁不能访问\n基于对主体（或主体所属组）的识别来限制对客体的访问\n\n基于列的访问控制表，跟资源，放在FCB\n\n基于行的权能表，跟主体，放在PCB\n\n\n\n注意！&#x3D;&#x3D;属组的权限，属主一定具有&#x3D;&#x3D;，哪怕没标出来\n\n\n缺点：用户修改授权，操作系统无法区分是正常用户的正常行为还是攻击者的非法操作；攻击者可以利用DAC完成秘密信息的窃取\t\t\t\n&#x3D;&#x3D;强制访问控制MAC&#x3D;&#x3D;\n用于保护系统确定的对象，对此对象，用户不能进行更改\n系统设置\n对系统中的每个客体赋予相应安全属性（那四个等级？），当进程访问客体时，调用其安全 属性和访问方法，比较进程的安全属性和客体的安全属性，确定是否允许访问\n四个等级：\n\n&#x3D;&#x3D;绝密级&#x3D;&#x3D;\n&#x3D;&#x3D;机密级&#x3D;&#x3D;\n&#x3D;&#x3D;秘密级&#x3D;&#x3D;\n&#x3D;&#x3D;无密级&#x3D;&#x3D;\n\n机密性（用户角度）：向下读，向上写（军队从下属获取情报并汇报给上级）\n完整性（文件角度）：级别越低越不可信，向上读，向下写（军队从上级获取情报交给下级执行）\n基于角色的访问控制RBAC考虑到主体、客体数量多时，授权困难\n特点：\n\n最小特权原则\n角色继承：角色可互相重叠职责和权利；\n访问权限与角色相关联：不同角色不同权限\n角色容量：角色也是有容量的（每个角色最多可以有多少个用户），防止权限滥用\n职责分离：静态实现和动态实现\n\n\n&#x3D;&#x3D;最小特权原则&#x3D;&#x3D;：权限不能超过执行所需权限（执行只需要一点权限，就不能给他过大的权 限，以免出现安全问题，像那个侧通道攻击的竞争条件攻击）\n\n优点：降低管理开销；灵活表达和组织\n但与自主访问控制DAC区别是权限不能转让\n以上三种访问控制方法并不是完全独立的，他们互有交集，且除了这三种还有很多别的控制 方法\n\n其他还有：\n\n基于属性的访问控制ABAC\n\n基于任务的访问控制\n\n等等\n\n\n\n\n最小特权管理要较好地支持最小特权原则，应遵循以下原则：\n\n&#x3D;&#x3D;以进程（程序）逻辑为中心进行特权控制；&#x3D;&#x3D;\n\n以进程特权相关属性为依据对进程生命周期进行划分，进程在各个阶段中根据进程逻辑分配不同\n\n\n的特权；\n\n用户特权属性仅作为一种全局性的约束；\n\n在部分特权中引入特权参数提供更细粒度的特权控制；\n\n与原有机制的尽量兼容，对应用程序透明。\n\n\n\n(最大特权集∩可继承特权集)∪固定特权集\n\n？理解：文件允许的进程特权+文件固定的授予进程的特权\n\n可信通路使用户能借以直接同可信计算基TCB通信的一种机制（安全）\n审计机制审计类型\n\n系统级审计：有关登录\n应用级审计：文件的打开关闭等\n用户级审计：用户直接启动的所有命令等\n\n日志类型\n\n系统日志\n应用程序日志\n安全日志\n\n第十三章（安全模型）形式化安全模型非形式化安全模型\n安全模型按实现策略可分为：\n 保密性模型：如BLP\n完整性模型：如BiBa\n混合型模型：中国墙模型\n八个设计原则\n开发方法\n一般开发过程\n安全评测方法\n标准\n保密性模型（以BLP为例）关心保密性\n是可证明的数学模型；形式化模型包括的安全策略：\n\n自主安全策略（感觉和自主访问控制对应）：访问控制矩阵\n\n强制安全策略（感觉和强制访问控制对应）：简单安全特性和 * 属性（跟那四个密级有关）\n\n\n\n把那几个主体S和客体O都分好密级\n简单安全条件SSP：向下读（当S所处的密级&gt;&#x3D;O所处的密级时，S可以读O，即S对O有自主型读权限）\n* 属性：向上写（当S所处的密级&lt;&#x3D;O所处的密级时，S可以写O，即S对O具有自主型写权限）\n\n简单安全定理：设系统的初始安全状态为б0，T是状态转换集合，如果T中的每个元素都遵守简单安全条 件和*-属性，那么，对于每个i&gt;&#x3D;0,状态бi都是安全的。\nBLP扩展版安全等级定义了主体的密级和它针对的范畴\n\n安全等级（L，C）支配安全等级（L’,C’)，当且仅当L’&lt;&#x3D;L且C’包含在C中。例如：\n问题：\n\n不能保证完整性\n\n可信主体权限太大，不符合安全机制里的最小特权原则\n\n对共享机制没有描述\n\n\n完整性模型（以BiBa为例）关心完整性\n防止非授权修改系统信息\n主体和客体的完整级别（包括密级和范畴）分别反映他们的置信度安全策略：\n\n非自主策略\n\n下限标记策略：当主体访问客体时，将主体的完整性等级变为该主体和该课题完整性等级中 较低的那个等级\n环策略：主体和客体的完整性等级在执行操作的前后是固定不变的\n严格完整性策略：刚好跟BLP对偶，向上读，向下写\n\n\n自主策略\n\n\nBiBa可以和BLP模型相结合\nclark-willson\n","categories":["操作系统及安全"],"tags":["笔记"]}]